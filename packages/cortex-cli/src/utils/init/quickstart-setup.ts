/**
 * Vercel AI Quickstart Setup
 *
 * Handles installing the Vercel AI quickstart demo app
 * as a subfolder of the user's project.
 */

import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import pc from "picocolors";
import ora from "ora";
import type { AppConfig } from "../../types.js";
import { execCommand } from "../shell.js";

// ES module equivalents of __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Default port for the quickstart app
 */
const QUICKSTART_PORT = 3000;

/**
 * Files to exclude when copying template
 */
const EXCLUDE_FILES = [
  "node_modules",
  "package-lock.json",
  ".next",
  ".env.local",
  "tsconfig.tsbuildinfo",
];

/**
 * Find the quickstart template directory
 */
function findTemplatePath(): string | null {
  const possiblePaths = [
    // From dist/utils/init/
    path.join(__dirname, "../../../templates/vercel-ai-quickstart"),
    // From dist/utils/init/subdir
    path.join(__dirname, "../../../../templates/vercel-ai-quickstart"),
    // From installed package in node_modules
    path.join(
      process.cwd(),
      "node_modules",
      "@cortexmemory",
      "cli",
      "templates",
      "vercel-ai-quickstart",
    ),
  ];

  for (const tryPath of possiblePaths) {
    if (fs.existsSync(tryPath)) {
      return tryPath;
    }
  }

  return null;
}

/**
 * Recursively copy directory, excluding specified patterns
 */
async function copyDir(src: string, dest: string): Promise<void> {
  await fs.ensureDir(dest);

  const entries = await fs.readdir(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    // Skip excluded files/folders
    if (EXCLUDE_FILES.includes(entry.name)) {
      continue;
    }

    if (entry.isDirectory()) {
      await copyDir(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

/**
 * Update package.json to use npm packages instead of file: references
 */
async function updatePackageJson(
  quickstartPath: string,
  sdkVersion: string,
): Promise<void> {
  const packageJsonPath = path.join(quickstartPath, "package.json");

  if (!fs.existsSync(packageJsonPath)) {
    return;
  }

  const content = await fs.readFile(packageJsonPath, "utf-8");
  const pkg = JSON.parse(content);

  // Update dependencies to use npm packages
  if (pkg.dependencies) {
    // Replace file: references with npm versions
    if (
      pkg.dependencies["@cortexmemory/sdk"]?.startsWith("file:") ||
      pkg.dependencies["@cortexmemory/sdk"] === "*"
    ) {
      pkg.dependencies["@cortexmemory/sdk"] = `^${sdkVersion}`;
    }

    if (
      pkg.dependencies["@cortexmemory/vercel-ai-provider"]?.startsWith("file:")
    ) {
      // Use same version as SDK (they're released together)
      pkg.dependencies["@cortexmemory/vercel-ai-provider"] = `^${sdkVersion}`;
    }
  }

  // Update name to avoid conflicts
  pkg.name = "cortex-quickstart";

  await fs.writeFile(packageJsonPath, JSON.stringify(pkg, null, 2) + "\n");
}

/**
 * Graph configuration for quickstart
 */
export interface QuickstartGraphConfig {
  enabled: boolean;
  uri?: string;
  username?: string;
  password?: string;
}

/**
 * Create .env.local for the quickstart app
 */
async function createQuickstartEnv(
  quickstartPath: string,
  convexUrl: string,
  openaiApiKey?: string,
  graphConfig?: QuickstartGraphConfig,
): Promise<void> {
  const envPath = path.join(quickstartPath, ".env.local");

  let envContent = `# Cortex Memory Quickstart Environment
# Generated by cortex init

# Convex deployment URL
CONVEX_URL=${convexUrl}
NEXT_PUBLIC_CONVEX_URL=${convexUrl}

`;

  if (openaiApiKey) {
    envContent += `# OpenAI API key for embeddings and LLM
OPENAI_API_KEY=${openaiApiKey}

`;
  } else {
    envContent += `# OpenAI API key (required for chat functionality)
# Get your key at: https://platform.openai.com/api-keys
# OPENAI_API_KEY=sk-...

`;
  }

  envContent += `# Enable fact extraction (extracts structured facts from conversations)
CORTEX_FACT_EXTRACTION=true

`;

  // Graph sync configuration
  if (graphConfig?.enabled && graphConfig.uri) {
    envContent += `# Graph memory sync (enabled during init)
CORTEX_GRAPH_SYNC=true

# Graph database connection
NEO4J_URI=${graphConfig.uri}
NEO4J_USERNAME=${graphConfig.username || "neo4j"}
NEO4J_PASSWORD=${graphConfig.password || ""}
`;
  } else {
    envContent += `# Optional: Enable graph sync (requires Neo4j or Memgraph)
# CORTEX_GRAPH_SYNC=true
# NEO4J_URI=bolt://localhost:7687
# NEO4J_USERNAME=neo4j
# NEO4J_PASSWORD=your-password
`;
  }

  await fs.writeFile(envPath, envContent);
}

/**
 * Copy quickstart's Convex query files to the main convex folder
 *
 * The quickstart has read-only query files for the demo UI.
 * These are additive and don't conflict with the SDK's backend files.
 */
async function copyConvexQueryFiles(
  quickstartPath: string,
  projectPath: string,
): Promise<void> {
  const quickstartConvexPath = path.join(quickstartPath, "convex");
  const projectConvexPath = path.join(projectPath, "convex");

  if (!fs.existsSync(quickstartConvexPath)) {
    return;
  }

  // Files to copy (query files for demo UI)
  const queryFiles = ["health.ts"];

  for (const file of queryFiles) {
    const srcFile = path.join(quickstartConvexPath, file);
    const destFile = path.join(projectConvexPath, file);

    if (fs.existsSync(srcFile) && !fs.existsSync(destFile)) {
      await fs.copyFile(srcFile, destFile);
    }
  }

  // For files that exist in both (memories.ts, facts.ts, etc.),
  // the quickstart queries have different function names so we could append them.
  // For now, we'll skip merging to avoid complexity - the quickstart can use
  // the SDK's existing query functions or its own internal queries.
}

/**
 * Add quickstart script to root package.json
 */
async function addQuickstartScript(projectPath: string): Promise<void> {
  const packageJsonPath = path.join(projectPath, "package.json");

  if (!fs.existsSync(packageJsonPath)) {
    return;
  }

  const content = await fs.readFile(packageJsonPath, "utf-8");
  const pkg = JSON.parse(content);

  pkg.scripts = pkg.scripts || {};

  // Add quickstart script if not present
  if (!pkg.scripts.quickstart) {
    pkg.scripts.quickstart = "cd quickstart && npm run dev";
  }

  await fs.writeFile(packageJsonPath, JSON.stringify(pkg, null, 2) + "\n");
}

/**
 * Install the Vercel AI quickstart demo app
 *
 * @param projectPath - Absolute path to the user's project
 * @param sdkVersion - Version of @cortexmemory/sdk to use
 * @param convexUrl - Convex deployment URL
 * @param openaiApiKey - Optional OpenAI API key
 * @param graphConfig - Optional graph database configuration
 * @returns AppConfig for the installed app (includes projectPath for starting from anywhere)
 */
export async function installVercelAIQuickstart(
  projectPath: string,
  sdkVersion: string,
  convexUrl: string,
  openaiApiKey?: string,
  graphConfig?: QuickstartGraphConfig,
): Promise<AppConfig> {
  // Ensure we have an absolute path
  const absoluteProjectPath = path.resolve(projectPath);
  const quickstartPath = path.join(absoluteProjectPath, "quickstart");

  // Find template
  const templatePath = findTemplatePath();

  if (!templatePath) {
    throw new Error(
      "Vercel AI quickstart template not found. " +
        "Please ensure @cortexmemory/cli is properly installed.",
    );
  }

  console.log(pc.cyan("\n   Installing Vercel AI quickstart..."));

  // Copy template files
  const copySpinner = ora("Copying quickstart files...").start();
  await copyDir(templatePath, quickstartPath);
  copySpinner.succeed("Quickstart files copied");

  // Update package.json with npm package versions
  const updateSpinner = ora("Configuring package.json...").start();
  await updatePackageJson(quickstartPath, sdkVersion);
  updateSpinner.succeed("Package.json configured");

  // Create .env.local (including graph config if enabled)
  await createQuickstartEnv(
    quickstartPath,
    convexUrl,
    openaiApiKey,
    graphConfig,
  );
  console.log(pc.dim("   Created quickstart/.env.local"));

  // Copy Convex query files to main convex folder
  await copyConvexQueryFiles(quickstartPath, projectPath);

  // Add quickstart script to root package.json
  await addQuickstartScript(projectPath);
  console.log(pc.dim("   Added 'quickstart' script to package.json"));

  // Install dependencies
  // Use --legacy-peer-deps to handle potential version mismatches between
  // the quickstart template (ai@^6.x) and older published provider versions
  const installSpinner = ora("Installing quickstart dependencies...").start();
  try {
    const result = await execCommand("npm", ["install", "--legacy-peer-deps"], {
      cwd: quickstartPath,
      quiet: true,
    });

    if (result.code !== 0) {
      installSpinner.fail("Failed to install dependencies");
      console.error(pc.red(result.stderr));
      throw new Error("npm install failed in quickstart folder");
    }

    installSpinner.succeed("Quickstart dependencies installed");
  } catch (error) {
    installSpinner.fail("Failed to install dependencies");
    throw error;
  }

  console.log(pc.green("\n   ✓ Vercel AI quickstart installed"));
  console.log(pc.dim("   Location: ./quickstart"));
  console.log(pc.dim("   Run: npm run quickstart"));

  // Return app config with absolute projectPath for starting from anywhere
  return {
    type: "vercel-ai-quickstart",
    path: "quickstart",
    projectPath: absoluteProjectPath,
    enabled: true,
    port: QUICKSTART_PORT,
    startCommand: "npm run dev",
  };
}

/**
 * Get the PID file path for an app
 *
 * @param appName - App name (used as identifier)
 * @param projectPath - Project root path
 * @returns Path to the PID file
 */
export function getAppPidFilePath(appName: string, projectPath: string): string {
  // Sanitize app name for use in filename
  const safeName = appName.replace(/[^a-zA-Z0-9-_]/g, "-");
  return path.join(projectPath, `.cortex-app-${safeName}.pid`);
}

/**
 * Start a template app in the background
 *
 * @param appName - Display name for the app
 * @param app - App configuration (includes projectPath)
 */
export async function startApp(appName: string, app: AppConfig): Promise<void> {
  // Use app.projectPath (absolute) combined with app.path (relative)
  const appPath = path.join(app.projectPath, app.path);

  if (!fs.existsSync(appPath)) {
    console.log(pc.yellow(`   App "${appName}" not found at ${appPath}`));
    return;
  }

  const command = app.startCommand || "npm run dev";
  const [cmd, ...args] = command.split(" ");

  console.log(pc.dim(`   Starting ${appName} on port ${app.port || 3000}...`));

  // Create log file for the background process
  const logFile = path.join(app.projectPath, `.cortex-app-${appName}.log`);
  const logFd = fs.openSync(logFile, "a");

  // Use spawn to start in background
  const { spawn } = await import("child_process");

  const child = spawn(cmd, args, {
    cwd: appPath,
    env: {
      ...process.env,
      PORT: String(app.port || 3000),
    },
    detached: true,
    stdio: ["ignore", logFd, logFd],
  });

  // Close the file descriptor in parent process (child keeps it open)
  fs.closeSync(logFd);

  child.unref();

  // Save PID for later management (stop command)
  const pidFile = getAppPidFilePath(appName, app.projectPath);
  await fs.writeFile(pidFile, String(child.pid));

  console.log(
    pc.green(`   ✓ ${appName} started at http://localhost:${app.port || 3000}`),
  );
  console.log(pc.dim(`     PID: ${child.pid}`));
  console.log(pc.dim(`     Log: ${path.basename(logFile)}`));
}

/**
 * Stop a running app by its PID file
 *
 * @param appName - App name (used to find PID file)
 * @param projectPath - Project root path
 * @returns True if the app was stopped, false if it wasn't running
 */
export async function stopApp(
  appName: string,
  projectPath: string,
): Promise<boolean> {
  const pidFile = getAppPidFilePath(appName, projectPath);

  try {
    const pid = await fs.readFile(pidFile, "utf-8");
    const pidNum = parseInt(pid.trim());

    if (isNaN(pidNum)) {
      await fs.remove(pidFile);
      return false;
    }

    try {
      process.kill(pidNum, "SIGTERM");
      // Clean up PID file
      await fs.remove(pidFile);
      return true;
    } catch (e) {
      const err = e as { code?: string };
      if (err.code === "ESRCH") {
        // Process already dead, clean up PID file
        await fs.remove(pidFile);
        return false;
      }
      throw e;
    }
  } catch (e) {
    const err = e as { code?: string };
    if (err.code === "ENOENT") {
      // No PID file exists
      return false;
    }
    throw e;
  }
}

/**
 * Check if an app is running
 *
 * @param appName - App name (used to find PID file)
 * @param projectPath - Project root path
 * @returns Object with running status and PID if running
 */
export async function isAppRunning(
  appName: string,
  projectPath: string,
): Promise<{ running: boolean; pid?: number }> {
  const pidFile = getAppPidFilePath(appName, projectPath);

  try {
    const pid = await fs.readFile(pidFile, "utf-8");
    const pidNum = parseInt(pid.trim());

    if (isNaN(pidNum)) {
      await fs.remove(pidFile);
      return { running: false };
    }

    try {
      // Signal 0 checks if process exists without killing it
      process.kill(pidNum, 0);
      return { running: true, pid: pidNum };
    } catch {
      // Process not running, clean up stale PID file
      await fs.remove(pidFile);
      return { running: false };
    }
  } catch {
    return { running: false };
  }
}

/**
 * Find all app PID files in a project directory
 *
 * @param projectPath - Project root path
 * @returns Array of app names that have PID files
 */
export async function findAppPidFiles(
  projectPath: string,
): Promise<Array<{ name: string; pidFile: string }>> {
  const files = await fs.readdir(projectPath);
  const pidFiles = files.filter(
    (f) => f.startsWith(".cortex-app-") && f.endsWith(".pid"),
  );

  return pidFiles.map((pidFile) => {
    // Extract app name from ".cortex-app-{name}.pid"
    const name = pidFile.replace(/^\.cortex-app-/, "").replace(/\.pid$/, "");
    return { name, pidFile: path.join(projectPath, pidFile) };
  });
}

/**
 * Find process listening on a specific port
 *
 * @param port - Port number to check
 * @returns PID of the process or null if none found
 */
export async function findProcessByPort(port: number): Promise<number | null> {
  try {
    const { execSync } = await import("child_process");

    // Use lsof on macOS/Linux to find process by port
    const result = execSync(`lsof -i :${port} -t 2>/dev/null`, {
      encoding: "utf-8",
    }).trim();

    if (result) {
      const pid = parseInt(result.split("\n")[0], 10);
      return isNaN(pid) ? null : pid;
    }
    return null;
  } catch {
    // lsof returns non-zero if no process found
    return null;
  }
}

/**
 * Stop a process by port number
 *
 * @param port - Port number
 * @param signal - Signal to send (default: SIGTERM)
 * @returns True if process was stopped, false otherwise
 */
export async function stopProcessByPort(
  port: number,
  signal: NodeJS.Signals = "SIGTERM",
): Promise<boolean> {
  const pid = await findProcessByPort(port);
  if (!pid) {
    return false;
  }

  try {
    process.kill(pid, signal);
    return true;
  } catch {
    return false;
  }
}
