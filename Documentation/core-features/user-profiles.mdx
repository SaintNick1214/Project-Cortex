---
id: user-profiles
title: User Profiles
sidebar_position: 4
description: Enable memories to follow users across tools with GDPR-compliant deletion
---

# User Profiles

<Callout type="info" title="Memory Follows the User">
  User profiles enable **memories to follow users across any tool**. Same `userId` = same memories, whether accessed from Cursor, Claude, custom apps, or any MCP-connected tool. This is the foundation of [Hive Mode](/core-features/hive-mode).
</Callout>

---

## Quick Start

```typescript
// Create/update a user profile
await cortex.users.update("user-123", {
  displayName: "Alex Johnson",
  email: "alex@example.com",
  preferences: { theme: "dark", language: "en" },
});

// Get user profile (works from any memory space)
const user = await cortex.users.get("user-123");
console.log(user.data.displayName);  // "Alex Johnson"
```

---

## Why User Profiles Exist

<Callout type="info" title="Memory Follows the User">
  The primary purpose of user profiles is **cross-tool memory sharing**. As long as the same `userId` is passed to Cortex, memories follow the user regardless of which tool they're usingâ€”Cursor, Claude, custom apps, or any MCP-connected tool. This is a core enabler of [Hive Mode](/core-features/hive-mode).
</Callout>

```typescript
// In Cursor: Store a preference
await cortex.memory.remember({
  memorySpaceId: 'user-123-space',
  userId: 'user-123',  // Same userId
  userMessage: 'I prefer TypeScript',
  // ...
});

// In Claude Desktop: Recall the same memory
const memories = await cortex.memory.recall({
  memorySpaceId: 'user-123-space', 
  userId: 'user-123',  // Same userId = same memories
  query: 'programming preferences',
});
// Returns: "User prefers TypeScript" - stored in Cursor, recalled in Claude!
```

<Callout type="tip" title="GDPR Cascade Deletion">
  A critical secondary benefit: One API call removes ALL user data across ALL memory layers for GDPR compliance.
</Callout>

```typescript
// GDPR "right to be forgotten" - ONE call deletes everything
const result = await cortex.users.delete("user-123", { cascade: true });
// Deletes: profile, conversations, memories, facts, sessions, graph nodes
```

---

## User Profile Schema

<APITable parameters={[
  { name: "id", type: "string", required: true, description: "Unique user identifier" },
  { name: "tenantId", type: "string", required: false, description: "Multi-tenancy isolation (auto-injected from AuthContext)" },
  { name: "data", type: "Record<string, unknown>", required: false, description: "Flexible user data - any structure you want" },
  { name: "version", type: "number", required: false, description: "Auto-incrementing version number" },
  { name: "createdAt", type: "number", required: false, description: "Creation timestamp (Unix ms)" },
  { name: "updatedAt", type: "number", required: false, description: "Last update timestamp (Unix ms)" },
]} />

### Suggested Data Structure

```typescript
await cortex.users.update("user-123", {
  displayName: "Alex Johnson",
  email: "alex@example.com",
  preferences: {
    theme: "dark",
    language: "en",
    timezone: "America/New_York",
  },
  metadata: {
    tier: "pro",
    signupDate: Date.now(),
  },
});
```

---

## User Operations

<Tabs>
  <TabItem value="create" label="Create/Update">

```typescript
// Create or update user profile
await cortex.users.update("user-123", {
  displayName: "Alex Johnson",
  email: "alex@example.com",
  preferences: {
    theme: "dark",
    language: "en",
  },
  metadata: {
    tier: "pro",
    signupDate: Date.now(),
  },
});
```

<Callout type="tip">
  Updates automatically deep-merge with existing data and create a new version.
</Callout>

  </TabItem>
  <TabItem value="read" label="Read">

```typescript
// Get user profile
const user = await cortex.users.get("user-123");

console.log(user.data.displayName);        // "Alex Johnson"
console.log(user.data.preferences.theme);  // "dark"
console.log(user.version);                 // Version number
```

  </TabItem>
  <TabItem value="history" label="Version History">

```typescript
// Get all versions
const history = await cortex.users.getHistory("user-123");

history.forEach(v => {
  console.log(`v${v.version}: ${v.data.displayName} (${new Date(v.timestamp)})`);
});

// Get profile at specific time
const historical = await cortex.users.getAtTimestamp(
  "user-123",
  new Date("2025-08-01")
);
```

  </TabItem>
  <TabItem value="delete" label="Delete (GDPR)">

```typescript
// Delete user profile only
await cortex.users.delete("user-123");

// GDPR cascade - delete ALL user data
const result = await cortex.users.delete("user-123", { 
  cascade: true,
  verify: true,
});

console.log(`Deleted ${result.totalDeleted} records`);
```

<Callout type="danger">
  Cascade permanently deletes the user and ALL their data across ALL memory spaces and layers.
</Callout>

  </TabItem>
</Tabs>

---

## GDPR Compliance

<Callout type="warning" title="Right to Erasure">
  Cortex supports GDPR "right to be forgotten" via cascade deletion with verification.
</Callout>

<Steps>
  <Step title="Preview deletion (optional)">

```typescript
const preview = await cortex.users.delete("user-123", {
  cascade: true,
  dryRun: true,  // Preview only
});
console.log(`Would delete ${preview.totalDeleted} records`);
```

  </Step>
  <Step title="Export user data (GDPR requirement)">

```typescript
const exportData = await cortex.users.export({
  format: "json",
  filters: { displayName: "user-123" },
  includeConversations: true,
  includeMemories: true,
});
await saveToFile(`gdpr-export-${userId}.json`, exportData);
```

  </Step>
  <Step title="Execute cascade deletion">

```typescript
const result = await cortex.users.delete("user-123", {
  cascade: true,
  verify: true,
});
```

  </Step>
  <Step title="Automatic cleanup completes">

Cortex deletes from ALL stores: User profile, all conversations (Layer 1a), all memories (Layer 2), all facts (Layer 3), all sessions, and graph nodes (if configured).

  </Step>
</Steps>

### Deletion Result

```typescript
{
  userId: "user-123",
  deletedAt: 1735689600000,
  conversationsDeleted: 15,
  vectorMemoriesDeleted: 145,
  factsDeleted: 89,
  totalDeleted: 547,
  verification: { complete: true, issues: [] }
}
```

---

## Automatic User Creation

<Callout type="tip" title="Auto-Creation on First Memory">
  User profiles are auto-created when using `remember()` if they don't exist:

```typescript
// First call with userId creates the profile automatically
await cortex.memory.remember({
  memorySpaceId: "user-123-space",
  userId: "user-123",      // Auto-creates profile
  userName: "Alex",        // Used for displayName
  // ...
});
```

</Callout>

---

## Querying Users

<Tabs>
  <TabItem value="search" label="Search">

```typescript
// Search by displayName
const users = await cortex.users.search({
  displayName: "alex",
  limit: 50,
});

// Search recent users
const recent = await cortex.users.search({
  createdAfter: Date.now() - 30 * 24 * 60 * 60 * 1000,
  sortBy: "createdAt",
  sortOrder: "desc",
});
```

  </TabItem>
  <TabItem value="list" label="List (Paginated)">

```typescript
const page1 = await cortex.users.list({
  limit: 50,
  offset: 0,
  sortBy: "createdAt",
  sortOrder: "desc",
});

console.log(`${page1.users.length} of ${page1.total} users`);
```

  </TabItem>
  <TabItem value="count" label="Count">

```typescript
const total = await cortex.users.count();

const activeThisWeek = await cortex.users.count({
  updatedAfter: Date.now() - 7 * 24 * 60 * 60 * 1000,
});
```

  </TabItem>
  <TabItem value="bulk" label="Bulk Operations">

```typescript
// Update multiple users
await cortex.users.updateMany(
  ["user-1", "user-2", "user-3"],
  { data: { welcomeEmailSent: true } }
);

// Update by filter
await cortex.users.updateMany(
  { createdAfter: Date.now() - 7 * 24 * 60 * 60 * 1000 },
  { data: { welcomeEmailSent: true } }
);
```

  </TabItem>
</Tabs>

---

## Multi-Tenancy Support

<Callout type="info" title="Automatic Tenant Isolation">
  Use AuthContext for automatic tenant scoping on all user operations.
</Callout>

```typescript
import { Cortex, createAuthContext } from "@cortexmemory/sdk";

const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL!,
  auth: createAuthContext({
    tenantId: "customer-acme",
    userId: "admin-user",
  }),
});

// All operations automatically scoped to tenant
await cortex.users.update("user-123", { displayName: "Alex" });
// tenantId: "customer-acme" auto-injected

const users = await cortex.users.list({ limit: 100 });
// Only returns users for "customer-acme"

await cortex.users.delete("user-123", { cascade: true });
// Only deletes within "customer-acme" tenant
```

See [Isolation Boundaries](/security/isolation-boundaries) for complete multi-tenancy documentation.

---

## Common Patterns

### Initialize on First Contact

```typescript
async function ensureUserProfile(userId: string, message: string) {
  let user = await cortex.users.get(userId);
  
  if (!user) {
    await cortex.users.update(userId, {
      displayName: userId,
      preferences: {
        language: detectLanguage(message),
        timezone: "UTC",
      },
      metadata: {
        tier: "free",
        signupDate: Date.now(),
      },
    });
    user = await cortex.users.get(userId);
  }
  
  return user;
}
```

### Cross-Agent Context

```typescript
// All agents access the same profile
const user = await cortex.users.get(userId);

// Support agent
const greeting = `Hello ${user.data.displayName}!`;

// Sales agent
if (user.data.metadata.tier === "free") {
  offerUpgrade();
}

// Billing agent
sendInvoiceTo(user.data.email);
```

### Profile Validation

```typescript
import { z } from "zod";

const ProfileSchema = z.object({
  displayName: z.string().min(1).max(100),
  email: z.string().email().optional(),
  preferences: z.object({
    theme: z.enum(["light", "dark"]).optional(),
    language: z.string().length(2).optional(),
  }).optional(),
});

async function safeUpdate(userId: string, data: unknown) {
  const validated = ProfileSchema.parse(data);
  return await cortex.users.update(userId, validated);
}
```

---

## Best Practices

<Callout type="tip" title="Start Minimal">

```typescript
// Only require what you truly need
await cortex.users.update(userId, {
  displayName: "Alex",  // That's it!
});
// Add more fields over time as you learn about the user
```

</Callout>

<Callout type="warning" title="Privacy-First">

```typescript
// Don't store unnecessary PII
await cortex.users.update(userId, {
  preferences: {
    paymentMethod: "card-ending-1234",  // Reference only
  },
});
// Never store: SSN, full credit card, passwords
```

</Callout>

<Callout type="tip" title="Track Activity">

```typescript
// Update lastSeen on each interaction
await cortex.users.update(userId, {
  metadata: { lastSeen: Date.now() },
});
```

</Callout>

---

## Next Steps

<QuickNav>
  <QuickNavItem 
    title="User Operations API" 
    description="Complete API reference" 
    href="/api-reference/user-operations" 
  />
  <QuickNavItem 
    title="Memory Spaces" 
    description="User data per space" 
    href="/core-features/memory-spaces" 
  />
  <QuickNavItem 
    title="Isolation Boundaries" 
    description="Multi-tenancy model" 
    href="/security/isolation-boundaries" 
  />
  <QuickNavItem 
    title="Auth Integration" 
    description="AuthContext setup" 
    href="/integrations/auth-providers" 
  />
</QuickNav>
