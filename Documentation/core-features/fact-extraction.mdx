---
id: fact-extraction
title: Fact Extraction
sidebar_position: 9
description: LLM-powered fact extraction for 60-90% token savings
---

# Fact Extraction

<Callout type="info" title="60-90% Token Savings">
  Instead of feeding entire conversation histories to your LLM, extract salient facts and store them efficiently. This enables:
  
  - **Infinite context** - Recall from millions of messages
  - **Cost reduction** - 60-90% fewer tokens per request
  - **Better retrieval** - Structured facts are more searchable
</Callout>

---

## Quick Example

```
Raw Conversation (402 tokens):
User: "I moved from Paris to London last week. I'm working at Acme Corp 
       as a senior engineer. My commute is 30 minutes on the tube."

Extracted Facts (45 tokens):
1. User moved from Paris to London (last week)
2. User works at Acme Corp as Senior Engineer
3. User's commute: 30 minutes via tube

Storage: 89% reduction
```

---

## Extraction Modes

<Tabs>
  <TabItem value="automatic" label="Automatic (Batteries-Included)">

Configure an LLM once, facts extracted automatically:

```typescript
import { Cortex } from '@cortex-platform/sdk';
import { openai } from '@ai-sdk/openai';

// Configure Cortex with LLM client
const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL!,
  llm: openai('gpt-4'),  // Enables automatic fact extraction
});

// Facts extracted automatically - no callback needed!
await cortex.memory.remember({
  memorySpaceId: 'user-123-space',
  conversationId: 'conv-123',
  userMessage: 'My favorite color is blue',
  agentResponse: 'Got it!',
  userId: 'user-123',
  userName: 'Alice',
  // No extractFacts needed - LLM extracts automatically!
});

// Result: Facts extracted + belief revision applied + stored
```

<Callout type="tip" title="Zero Code per Call">
  Configure LLM once, get automatic extraction + deduplication + belief revision for all `remember()` calls. This is the **batteries-included** approach.
</Callout>

**Skip extraction for specific calls:**

```typescript
// Skip fact extraction for this conversation
await cortex.memory.remember({
  // ... params
  skipLayers: ['facts'],  // Don't extract facts this time
});
```

  </TabItem>
  <TabItem value="manual" label="Manual (Override)">

Override automatic extraction with your own logic:

```typescript
await cortex.memory.remember({
  memorySpaceId: 'user-123-space',
  conversationId: 'conv-123',
  userMessage: 'My favorite color is blue',
  agentResponse: 'Got it!',
  userId: 'user-123',
  userName: 'Alice',
  
  // Your extraction logic - overrides LLM config
  extractFacts: async (userMsg, agentResp) => [{
    fact: 'User prefers blue color',
    factType: 'preference',
    subject: 'user-123',
    predicate: 'favorite_color',
    object: 'blue',
    confidence: 95,
  }],
});
```

<Callout type="info">
  Provide `extractFacts` callback to override automatic LLM extraction. Use your own LLM, prompts, regex rules, or any combination.
</Callout>

  </TabItem>
  <TabItem value="direct" label="Direct Storage">

Store facts directly without conversations:

```typescript
await cortex.facts.store({
  memorySpaceId: 'user-123-space',
  userId: 'user-123',
  fact: 'User prefers blue color',
  factType: 'preference',
  subject: 'user-123',
  predicate: 'favorite_color',
  object: 'blue',
  confidence: 95,
  sourceType: 'manual',
});
```

  </TabItem>
</Tabs>

---

## Fact Schema

<APITable parameters={[
  { name: "fact", type: "string", required: true, description: "The extracted fact statement" },
  { name: "factType", type: "string", required: true, description: "'preference' | 'identity' | 'knowledge' | 'relationship' | 'event'" },
  { name: "subject", type: "string", required: false, description: "Entity the fact is about (e.g., 'user-123')" },
  { name: "predicate", type: "string", required: false, description: "Relationship type (e.g., 'favorite_color')" },
  { name: "object", type: "string", required: false, description: "Related value (e.g., 'blue')" },
  { name: "confidence", type: "number", required: true, description: "Confidence score (0-100)" },
  { name: "tags", type: "string[]", required: false, description: "Categorization tags" },
  { name: "aliases", type: "string[]", required: false, description: "Alternative phrasings for search" },
]} />

---

## Belief Revision

<Callout type="info" title="Automatic Conflict Resolution (v0.24.0+)">
  When you extract a fact that conflicts with an existing fact, Cortex handles it automatically:
  
  - **ADD**: New fact (no conflict)
  - **SUPERSEDE**: Old fact marked as superseded, new fact is current
  - **MERGE**: Compatible facts combined
  - **IGNORE**: Duplicate fact skipped
</Callout>

```typescript
// Old fact: "User prefers blue"
// New conversation: "Actually, I like purple now"

await cortex.memory.remember({
  memorySpaceId: 'user-123-space',
  conversationId: 'conv-456',
  userMessage: 'Actually, I like purple now',
  agentResponse: 'Updated!',
  userId: 'user-123',
  userName: 'Alice',
  
  extractFacts: async () => [{
    fact: 'User prefers purple',
    factType: 'preference',
    subject: 'user-123',
    predicate: 'favorite_color',
    object: 'purple',
    confidence: 95,
  }],
  
  beliefRevision: true,  // Automatically supersedes old "blue" fact
});
```

### Preview Conflicts

```typescript
const conflicts = await cortex.facts.checkConflicts({
  memorySpaceId: 'user-123-space',
  fact: 'User prefers purple',
  subject: 'user-123',
  predicate: 'favorite_color',
});

if (conflicts.hasConflicts) {
  console.log('Would supersede:', conflicts.conflictingFacts);
}
```

---

## Querying Facts

<Tabs>
  <TabItem value="search" label="Search Facts">

```typescript
// Search facts directly
const facts = await cortex.facts.search(spaceId, 'color preference');

// Or semantic search via memory API
const memories = await cortex.memory.search(spaceId, 'what colors?', {
  embedding: await embed('what colors?'),
  contentType: 'fact',
  limit: 5,
});
```

  </TabItem>
  <TabItem value="recall" label="Via recall()">

```typescript
// recall() automatically includes facts
const result = await cortex.memory.recall({
  memorySpaceId: spaceId,
  query: 'What colors does the user like?',
  embedding: await embed('What colors does the user like?'),
  sources: { facts: true },
});

result.items
  .filter(i => i.source === 'facts')
  .forEach(f => console.log(f.fact.fact));
```

  </TabItem>
  <TabItem value="filter" label="Filter by Type">

```typescript
// Get only preferences
const prefs = await cortex.facts.list({
  memorySpaceId: spaceId,
  factType: 'preference',
  isSuperseded: false,  // Current beliefs only
});

// Get only identity facts
const identity = await cortex.facts.list({
  memorySpaceId: spaceId,
  factType: 'identity',
});
```

  </TabItem>
</Tabs>

---

## Deduplication

<Callout type="info" title="Automatic Deduplication (v0.22.0+)">
  `memory.remember()` automatically deduplicates facts using semantic matching. Same fact stated differently won't create duplicates.
</Callout>

| Strategy | How it Works | Speed | Accuracy |
|----------|--------------|-------|----------|
| `semantic` | Embedding similarity (default) | Slower | Highest |
| `structural` | Subject + predicate + object match | Fast | Medium |
| `exact` | Normalized text match | Fastest | Low |

```typescript
// Use structural deduplication (faster)
await cortex.memory.remember({
  // ... params
  factDeduplication: 'structural',
});

// Disable deduplication
await cortex.memory.remember({
  // ... params
  factDeduplication: false,
});
```

---

## Fact History

```typescript
// Get change history for a specific fact
const changes = await cortex.facts.history('fact-123');

changes.forEach(event => {
  console.log(`${event.action} at ${new Date(event.timestamp).toISOString()}`);
  console.log(`  Reason: ${event.reason}`);
});

// Get the supersession chain (evolution over time)
const chain = await cortex.facts.getSupersessionChain('fact-123');
// Returns: [oldest] -> [older] -> [current]

// Get all versions of a fact
const versions = await cortex.facts.getHistory(spaceId, 'fact-123');
versions.forEach(v => console.log(`v${v.version}: ${v.fact}`));
```

---

## Best Practices

<Callout type="tip" title="Tune Confidence Threshold">

```typescript
// Discard low-confidence facts
extractFacts: async (user, agent) => {
  const facts = await extractWithLLM(user, agent);
  return facts.filter(f => f.confidence >= 70);
},
```

</Callout>

<Callout type="tip" title="Use Structured Facts for Dedup">

```typescript
// Good: Enables structural deduplication
{ fact: 'User prefers dark mode', subject: 'user-123', predicate: 'prefers', object: 'dark-mode' }

// Less good: No structure, relies on semantic dedup only
{ fact: 'User prefers dark mode' }
```

</Callout>

<Callout type="warning" title="Always Link to Conversations">

```typescript
// Facts automatically get conversationRef when using remember()
// This enables tracing facts back to source for audit
```

</Callout>

---

## Token Savings Analysis

```typescript
async function analyzeTokenSavings(conversationId: string) {
  const conv = await cortex.conversations.get(conversationId);
  const rawTokens = estimateTokens(conv.messages.map(m => m.text).join('\n'));

  const facts = await cortex.facts.list({
    'conversationRef.conversationId': conversationId,
  });
  const factTokens = estimateTokens(facts.map(f => f.fact).join('\n'));

  const savings = ((rawTokens - factTokens) / rawTokens) * 100;
  
  return { rawTokens, factTokens, savingsPercent: savings.toFixed(1) };
}

// Example: { rawTokens: 1250, factTokens: 125, savingsPercent: '90.0' }
```

---

## Next Steps

<QuickNav>
  <QuickNavItem 
    title="Facts API" 
    description="Complete facts reference" 
    href="/api-reference/facts-operations" 
  />
  <QuickNavItem 
    title="Fact Integration" 
    description="Advanced fact patterns" 
    href="/advanced-topics/fact-integration" 
  />
  <QuickNavItem 
    title="Semantic Search" 
    description="Search facts efficiently" 
    href="/core-features/semantic-search" 
  />
  <QuickNavItem 
    title="Facts vs Conversations" 
    description="Trade-off analysis" 
    href="/advanced-topics/facts-vs-conversations" 
  />
</QuickNav>
