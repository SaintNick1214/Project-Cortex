---
id: sessions-operations
title: Sessions Operations API
sidebar_position: 8
description: Complete API reference for session lifecycle management and multi-session support in Cortex.
---

# Sessions Operations API

<Callout type="info">

**Last Updated**: 2026-01-01

</Callout>

Complete API reference for session lifecycle management and multi-session support.

## Overview

The Sessions API (`cortex.sessions.*`) provides native session management for user-facing agentic platforms. Sessions track user interactions, manage activity timeouts, and provide an isolated context for conversations.

**Key Features:**

- **Multi-Session Support**: Users can have multiple active sessions (web, mobile, API)
- **Activity Tracking**: Automatic idle detection and session expiration
- **Extensible Metadata**: Fully flexible metadata for any developer needs
- **Configurable Timeouts**: Per-tenant or per-session lifecycle policies (via Governance API)
- **GDPR Integration**: Sessions cascade delete with user deletion

---

## Session Lifecycle

```
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   ACTIVE    │──────│    IDLE     │──────│   ENDED     │
│             │      │             │      │             │
│ User active │      │ No activity │      │ Terminated  │
│ < 30min     │      │ < 24h       │      │             │
└─────────────┘      └─────────────┘      └─────────────┘
       │                    │                    ▲
       │    touch()         │    expireIdle()    │
       └────────────────────┼────────────────────┘
                            │
                    After 24h idle
```

**Default Timeouts (Configurable via Governance):**

<APITable
  parameters={[
    { name: "Active", type: "30m", required: false, description: "No activity moves to idle" },
    { name: "Idle", type: "24h", required: false, description: "After 24h idle, session is ended" },
  ]}
/>

---

## Session Type

```typescript
interface Session {
  _id: string; // Convex document ID
  sessionId: string; // Unique session identifier
  userId: string;
  tenantId?: string;
  memorySpaceId?: string;

  // Session state
  status: "active" | "idle" | "ended";
  startedAt: number;
  lastActiveAt: number;
  endedAt?: number;
  expiresAt?: number;

  // Fully extensible metadata - any shape you need
  metadata?: SessionMetadata;

  // Stats
  messageCount: number;
  memoryCount: number;
}

interface SessionMetadata {
  device?: string;
  browser?: string;
  browserVersion?: string;
  os?: string;
  deviceType?: "desktop" | "mobile" | "tablet" | string;
  ip?: string;
  location?: string;
  timezone?: string;
  language?: string;
  userAgent?: string;
  [key: string]: unknown; // Any additional custom fields
}
```

### Metadata Flexibility

The `metadata` field is completely flexible and can store any data your application needs:

<Tabs>
<TabItem value="device" label="Device Info">

```typescript
// Device and client info
await cortex.sessions.create({
  userId: "user-123",
  metadata: {
    deviceType: "mobile",
    appVersion: "2.1.0",
    platform: "ios",
    deviceId: "device-xyz",
  },
});
```

</TabItem>
<TabItem value="auth" label="Auth Claims">

```typescript
// Auth provider claims
await cortex.sessions.create({
  userId: "user-123",
  metadata: {
    authProvider: "auth0",
    authMethod: "oauth",
    email: "user@example.com",
    roles: ["admin", "editor"],
    permissions: ["read", "write", "delete"],
    customClaim: "any-value",
  },
});
```

</TabItem>
<TabItem value="geo" label="Geographic">

```typescript
// Geographic context
await cortex.sessions.create({
  userId: "user-123",
  metadata: {
    ipAddress: "192.168.1.1",
    country: "US",
    timezone: "America/New_York",
    locale: "en-US",
  },
});
```

</TabItem>
</Tabs>

---

## Core Operations

### create()

Create a new session for a user.

**Signature:**

```typescript
cortex.sessions.create(params: CreateSessionParams): Promise<Session>
```

**Parameters:**

<APITable
  parameters={[
    { name: "sessionId", type: "string", required: false, description: "Custom ID (auto-generated if not provided)" },
    { name: "userId", type: "string", required: true, description: "User this session belongs to" },
    { name: "tenantId", type: "string", required: false, description: "Multi-tenant isolation" },
    { name: "memorySpaceId", type: "string", required: false, description: "Associate with memory space" },
    { name: "metadata", type: "SessionMetadata", required: false, description: "Fully extensible metadata" },
    { name: "expiresAt", type: "number", required: false, description: "Override default expiry (ms since epoch)" },
  ]}
/>

**Example:**

```typescript
// Create a new session
const session = await cortex.sessions.create({
  userId: "user-123",
  tenantId: "tenant-abc",
  memorySpaceId: "user-123-personal",
  metadata: {
    deviceType: "web",
    userAgent: "Mozilla/5.0...",
    authProvider: "google",
  },
});

console.log(`Session ${session.sessionId} started`);
```

---

### get()

Get a session by ID.

**Signature:**

```typescript
cortex.sessions.get(sessionId: string): Promise<Session | null>
```

**Parameters:**

<APITable
  parameters={[
    { name: "sessionId", type: "string", required: true, description: "The unique session identifier to retrieve" },
  ]}
/>

**Example:**

```typescript
const session = await cortex.sessions.get("session-xyz");
if (session) {
  console.log(`Status: ${session.status}`);
  console.log(`Last active: ${new Date(session.lastActiveAt)}`);
}
```

---

### getOrCreate()

Get existing active session for user, or create a new one.

**Signature:**

```typescript
cortex.sessions.getOrCreate(
  userId: string,
  metadata?: Record<string, unknown>
): Promise<Session>
```

**Parameters:**

<APITable
  parameters={[
    { name: "userId", type: "string", required: true, description: "User ID to find or create session for" },
    { name: "metadata", type: "Record<string, unknown>", required: false, description: "Metadata for new session if created" },
  ]}
/>

**Example:**

```typescript
// Returns existing active session or creates new one
const session = await cortex.sessions.getOrCreate("user-123", {
  deviceType: "mobile",
});

// Useful for "resume session" flows
console.log(`Using session ${session.sessionId}`);
```

---

### touch()

Update session activity timestamp (heartbeat).

**Signature:**

```typescript
cortex.sessions.touch(sessionId: string): Promise<void>
```

**Parameters:**

<APITable
  parameters={[
    { name: "sessionId", type: "string", required: true, description: "Session ID to update activity for" },
  ]}
/>

**Example:**

```typescript
// Update activity on every user interaction
await cortex.sessions.touch(session.sessionId);

// Prevents session from going idle
```

---

### end()

Explicitly end a session.

**Signature:**

```typescript
cortex.sessions.end(sessionId: string): Promise<void>
```

**Parameters:**

<APITable
  parameters={[
    { name: "sessionId", type: "string", required: true, description: "Session ID to end" },
  ]}
/>

**Example:**

```typescript
// End session on logout
await cortex.sessions.end(session.sessionId);

// Session is now 'ended' and cannot be resumed
```

---

### endAll()

End all active sessions for a user.

**Signature:**

```typescript
cortex.sessions.endAll(
  userId: string,
  options?: EndAllOptions
): Promise<EndSessionsResult>
```

**Parameters:**

<APITable
  parameters={[
    { name: "userId", type: "string", required: true, description: "User ID to end all sessions for" },
    { name: "options.tenantId", type: "string", required: false, description: "Tenant ID for multi-tenant isolation. When provided, only ends sessions for the user within that tenant. Without this (and no AuthContext), ALL sessions for the userId across ALL tenants are ended." },
  ]}
/>

**Returns:**

<APITable
  parameters={[
    { name: "ended", type: "number", required: true, description: "Number of sessions ended" },
    { name: "sessionIds", type: "string[]", required: true, description: "IDs of sessions that were ended" },
  ]}
/>

**Example:**

```typescript
// End all sessions on password change
const result = await cortex.sessions.endAll("user-123");
console.log(`Ended ${result.ended} sessions`);
console.log(`Session IDs: ${result.sessionIds.join(", ")}`);

// End sessions only for a specific tenant (multi-tenant safe)
const tenantResult = await cortex.sessions.endAll("user-123", {
  tenantId: "tenant-abc",
});
console.log(`Ended ${tenantResult.ended} sessions in tenant`);
```

---

### list()

List sessions with filters.

**Signature:**

```typescript
cortex.sessions.list(filters: SessionFilters): Promise<Session[]>
```

**Parameters:**

<APITable
  parameters={[
    { name: "userId", type: "string", required: false, description: "Filter by user ID" },
    { name: "tenantId", type: "string", required: false, description: "Filter by tenant ID" },
    { name: "memorySpaceId", type: "string", required: false, description: "Filter by memory space" },
    { name: "status", type: "'active' | 'idle' | 'ended'", required: false, description: "Filter by status" },
    { name: "limit", type: "number", required: false, default: "50", description: "Max results (1-1000)" },
    { name: "offset", type: "number", required: false, default: "0", description: "Pagination offset" },
  ]}
/>

<Callout
  type="tip"
  icon="sparkles"
>

**PLANNED:** Date range filters (`startedAfter`, `startedBefore`) are planned for a future release.

</Callout>

**Example:**

```typescript
// Get all active sessions for a user
const activeSessions = await cortex.sessions.list({
  userId: "user-123",
  status: "active",
});

// Get tenant-wide sessions
const tenantSessions = await cortex.sessions.list({
  tenantId: "tenant-abc",
  status: "active",
  limit: 100,
});

// Get sessions by memory space
const spaceSessions = await cortex.sessions.list({
  memorySpaceId: "project-workspace",
  status: "active",
});
```

---

### count()

Count sessions matching filters.

**Signature:**

```typescript
cortex.sessions.count(filters: SessionFilters): Promise<number>
```

**Parameters:**

<APITable
  parameters={[
    { name: "userId", type: "string", required: false, description: "Filter by user ID" },
    { name: "tenantId", type: "string", required: false, description: "Filter by tenant ID" },
    { name: "memorySpaceId", type: "string", required: false, description: "Filter by memory space" },
    { name: "status", type: "'active' | 'idle' | 'ended'", required: false, description: "Filter by status" },
  ]}
/>

**Example:**

```typescript
const activeSessions = await cortex.sessions.count({
  tenantId: "tenant-abc",
  status: "active",
});

console.log(`${activeSessions} users currently online`);
```

---

### getActive()

Get all active sessions for a user.

**Signature:**

```typescript
cortex.sessions.getActive(userId: string): Promise<Session[]>
```

**Parameters:**

<APITable
  parameters={[
    { name: "userId", type: "string", required: true, description: "User ID to get active sessions for" },
  ]}
/>

**Example:**

```typescript
const sessions = await cortex.sessions.getActive("user-123");
console.log(`User has ${sessions.length} active sessions`);

// Useful for "active devices" view
sessions.forEach((s) => {
  console.log(`- ${s.metadata?.deviceType}: ${s.sessionId}`);
});
```

---

### expireIdle()

Expire idle sessions (typically run as background job).

**Signature:**

```typescript
cortex.sessions.expireIdle(options?: ExpireSessionsOptions): Promise<{ expired: number }>
```

**Parameters:**

<APITable
  parameters={[
    { name: "tenantId", type: "string", required: false, description: "Limit to specific tenant" },
    { name: "idleTimeout", type: "number", required: false, default: "1800000", description: "Idle timeout in milliseconds (default: 30 minutes)" },
  ]}
/>

<Callout
  type="tip"
  icon="sparkles"
>

**PLANNED:** Dry run mode (`dryRun: boolean`) is planned for a future release to preview without expiring.

</Callout>

**Example:**

```typescript
// Background job to clean up idle sessions
const result = await cortex.sessions.expireIdle({
  tenantId: "tenant-abc",
});
console.log(`Expired ${result.expired} idle sessions`);

// Custom idle timeout (15 minutes)
const customResult = await cortex.sessions.expireIdle({
  tenantId: "tenant-abc",
  idleTimeout: 15 * 60 * 1000, // 15 minutes in ms
});
```

---

## Session Policies (Governance)

Session lifecycle timeouts are configurable via the Governance API.

```typescript
await cortex.governance.setPolicy({
  organizationId: "org-123",

  // Session lifecycle configuration
  sessions: {
    lifecycle: {
      idleTimeout: "30m", // Duration before session becomes idle
      maxDuration: "24h", // Maximum session duration regardless of activity
      autoExtend: true, // Automatically extend on activity
      warnBeforeExpiry: "5m", // Optional: warn user before expiry
    },
    cleanup: {
      autoExpireIdle: true, // Automatically expire idle sessions
      deleteEndedAfter: "30d", // Delete ended sessions after 30 days
      archiveAfter: "7d", // Optional: archive before deletion
    },
    limits: {
      maxActiveSessions: 10, // Optional: max concurrent sessions per user
      maxSessionsPerDevice: 3, // Optional: max sessions per device type
    },
  },
});
```

See [Governance Policies API](/api-reference/governance-policies-api) for full configuration options.

---

## Multi-Tenancy

Sessions support full multi-tenant isolation via `tenantId`:

```typescript
// Create tenant-scoped session
const session = await cortex.sessions.create({
  userId: 'user-123',
  tenantId: 'customer-abc',  // SaaS platform isolation
  metadata: { ... },
});

// Query sessions within tenant
const tenantSessions = await cortex.sessions.list({
  tenantId: 'customer-abc',
  status: 'active',
});
```

---

## Integration with Auth Context

Sessions integrate with the Auth Context system for tenant isolation:

```typescript
import { createAuthContext } from "@cortex-platform/sdk";

// Create auth context with session info
const auth = createAuthContext({
  userId: "user-123",
  sessionId: "session-xyz",
  tenantId: "tenant-abc",
  authProvider: "auth0",
  claims: {
    email: "user@example.com",
    roles: ["admin"],
  },
});

// Initialize Cortex with auth context
const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL!,
  auth,
});

// tenantId is automatically injected from auth context
// This provides tenant isolation without passing tenantId to every call
const session = await cortex.sessions.create({
  userId: "user-123",
  // tenantId is auto-injected from auth context
  metadata: { deviceType: "web" },
});

// Queries are automatically scoped to the tenant
const sessions = await cortex.sessions.list({
  userId: "user-123",
  // tenantId is auto-injected, only returns sessions for this tenant
});
```

<Callout type="note">

The `sessionId` in AuthContext is for reference/tracking purposes. Session activity tracking (incrementing message/memory counts) should be done explicitly by calling `touch()` on user interactions.

</Callout>

---

## GDPR Cascade

Sessions are included in GDPR cascade deletion:

```typescript
// When deleting a user, all their sessions are also deleted
await cortex.users.delete("user-123", { cascade: true });

// Sessions are deleted as part of the cascade:
// ✅ User profile
// ✅ All sessions for user  <-- NEW
// ✅ All conversations
// ✅ All memories
// ✅ All facts
// ✅ Graph nodes (if configured)
```

---

## Real-World Patterns

### Session Resume Flow

```typescript
async function handleUserConnection(
  userId: string,
  metadata: Record<string, unknown>,
) {
  // Try to get existing active session
  const existingSessions = await cortex.sessions.getActive(userId);

  if (existingSessions.length > 0) {
    // Resume most recent session
    const session = existingSessions[0];
    await cortex.sessions.touch(session.sessionId);
    return session;
  }

  // Create new session
  return cortex.sessions.create({
    userId,
    metadata,
  });
}
```

### Multi-Device Support

```typescript
async function getActiveSessions(userId: string) {
  const sessions = await cortex.sessions.getActive(userId);

  return sessions.map((s) => ({
    id: s.sessionId,
    device: s.metadata?.deviceType || "unknown",
    lastActive: new Date(s.lastActiveAt),
    isCurrent: s.sessionId === currentSessionId,
  }));
}

async function logoutOtherDevices(userId: string, currentSessionId: string) {
  const sessions = await cortex.sessions.getActive(userId);

  for (const session of sessions) {
    if (session.sessionId !== currentSessionId) {
      await cortex.sessions.end(session.sessionId);
    }
  }
}
```

### Session Analytics

```typescript
async function getSessionStats(tenantId: string) {
  const [active, idle, ended] = await Promise.all([
    cortex.sessions.count({ tenantId, status: "active" }),
    cortex.sessions.count({ tenantId, status: "idle" }),
    cortex.sessions.count({ tenantId, status: "ended" }),
  ]);

  return {
    currentlyOnline: active,
    recentlyActive: idle,
    totalSessions: active + idle + ended,
  };
}
```

---

## Error Handling

### SessionValidationError

The Sessions API throws `SessionValidationError` for client-side validation failures:

```typescript
import { SessionValidationError } from "@cortex-platform/sdk";

try {
  await cortex.sessions.create({
    userId: "", // Invalid: empty userId
  });
} catch (error) {
  if (error instanceof SessionValidationError) {
    console.log(`Validation error: ${error.message}`);
    console.log(`Code: ${error.code}`); // e.g., "EMPTY_USER_ID"
    console.log(`Field: ${error.field}`); // e.g., "userId"
  }
}
```

**Validation Error Codes:**

<APITable
  parameters={[
    { name: "INVALID_SESSION_ID", type: "error", required: false, description: "sessionId must be a string" },
    { name: "EMPTY_SESSION_ID", type: "error", required: false, description: "sessionId cannot be empty" },
    { name: "SESSION_ID_TOO_LONG", type: "error", required: false, description: "sessionId cannot exceed 256 characters" },
    { name: "INVALID_USER_ID", type: "error", required: false, description: "userId must be a string" },
    { name: "EMPTY_USER_ID", type: "error", required: false, description: "userId cannot be empty" },
    { name: "USER_ID_TOO_LONG", type: "error", required: false, description: "userId cannot exceed 256 characters" },
    { name: "INVALID_TENANT_ID", type: "error", required: false, description: "tenantId must be a string" },
    { name: "EMPTY_TENANT_ID", type: "error", required: false, description: "tenantId cannot be empty" },
    { name: "TENANT_ID_TOO_LONG", type: "error", required: false, description: "tenantId cannot exceed 256 characters" },
    { name: "INVALID_STATUS", type: "error", required: false, description: "status must be a string" },
    { name: "INVALID_STATUS_VALUE", type: "error", required: false, description: "status must be: active, idle, or ended" },
    { name: "INVALID_PARAMS", type: "error", required: false, description: "Session params must be an object" },
    { name: "MISSING_USER_ID", type: "error", required: false, description: "userId is required" },
    { name: "INVALID_MEMORY_SPACE_ID", type: "error", required: false, description: "memorySpaceId must be a string" },
    { name: "INVALID_EXPIRES_AT", type: "error", required: false, description: "expiresAt must be a positive number" },
    { name: "INVALID_METADATA", type: "error", required: false, description: "metadata must be a plain object" },
    { name: "INVALID_FILTERS", type: "error", required: false, description: "Session filters must be an object" },
    { name: "INVALID_LIMIT", type: "error", required: false, description: "limit must be a number between 1 and 1000" },
    { name: "INVALID_OFFSET", type: "error", required: false, description: "offset must be a non-negative number" },
  ]}
/>

### Runtime Errors

Backend operations throw standard `Error` for runtime failures:

```typescript
try {
  await cortex.sessions.touch("non-existent-session");
} catch (error) {
  if (error instanceof Error) {
    // Error message: "Session not found: non-existent-session"
    console.log(error.message);
  }
}
```

<Callout
  type="tip"
  icon="sparkles"
>

**PLANNED:** Session-specific error codes (`CortexErrorCode.SESSION_NOT_FOUND`, `CortexErrorCode.SESSION_EXPIRED`, `CortexErrorCode.SESSION_ALREADY_ENDED`) are planned for a future release to provide more structured error handling.

</Callout>

---

## Related APIs

<QuickNav>
  <QuickNavItem
    title="User Operations"
    icon="user"
    href="/api-reference/user-operations"
    description="User profiles and GDPR deletion"
  />
  <QuickNavItem
    title="Auth Integration"
    icon="lock"
    href="/integrations/auth-providers"
    description="Authentication context"
  />
  <QuickNavItem
    title="Governance Policies"
    icon="shield"
    href="/api-reference/governance-policies-api"
    description="Session lifecycle policies"
  />
  <QuickNavItem
    title="Memory Operations"
    icon="brain"
    href="/api-reference/memory-operations"
    description="Session-scoped memories"
  />
</QuickNav>
