---
id: overview
title: API Reference Overview
sidebar_position: 1
description: Complete guide to navigating and using the Cortex API - a persistent memory system for AI agents built on Convex
---

# API Reference Overview

Welcome to the Cortex API Reference! This guide explains how to navigate the documentation and use Cortex effectively.

## What is Cortex?

Cortex is a **persistent memory system for AI agents** built on Convex. It provides:

<FeatureGrid>
  <FeatureCard
    icon="layers"
    title="Four-Layer Architecture"
    description="ACID stores + Vector index + Facts store + Convenience API"
    size="medium"
  />
  <FeatureCard
    icon="shield"
    title="Memory Space Isolation"
    description="Flexible boundaries (per user, team, or project)"
    size="medium"
  />
  <FeatureCard
    icon="users"
    title="Multi-Tenancy"
    description="Built-in tenantId for SaaS platform isolation"
    size="medium"
  />
</FeatureGrid>

<FeatureGrid>
  <FeatureCard
    icon="bot"
    title="Hive Mode"
    description="Multiple tools share one memory space (zero duplication)"
    size="large"
  />
  <FeatureCard
    icon="memory"
    title="Infinite Context"
    description="Never run out of context via retrieval"
    size="large"
  />
  <FeatureCard
    icon="history"
    title="Automatic Versioning"
    description="Track how information changes over time"
    size="large"
  />
  <FeatureCard
    icon="brain"
    title="Belief Revision System"
    description="Intelligent fact management with conflict resolution"
    size="large"
  />
</FeatureGrid>

<FeatureGrid>
  <FeatureCard
    icon="lock"
    title="GDPR Compliance"
    description="Built-in cascade deletion (Cloud Mode)"
    size="medium"
  />
  <FeatureCard
    icon="search"
    title="Universal Filters"
    description="Same filters work across all operations"
    size="medium"
  />
  <FeatureCard
    icon="package"
    title="Embedding-Agnostic"
    description="Bring your own embeddings or use Cloud Mode"
    size="medium"
  />
</FeatureGrid>

## Documentation Structure

The API Reference is organized by architectural layers:

### Core Memory System (Start Here)

- **[Memory Operations](/api-reference/memory-operations)** - The main API you'll use
  - Layer 4 convenience (`cortex.memory.*`)
  - Full orchestration: `remember()`, `rememberStream()`, `recall()`
  - Search, get, update, delete operations
  - Orchestration Observer for real-time monitoring
- **[Memory Space Operations](/api-reference/memory-space-operations)** - Memory space management
  - Fundamental isolation boundary in Cortex
  - Explicit registration for production deployments
  - Hive Mode participant tracking
  - `register()`, `get()`, `list()`, `archive()`, `delete()`, `getStats()`
- **[Conversation Operations](/api-reference/conversation-operations)** - Layer 1a (ACID)
  - Immutable conversation threads (memorySpace-scoped)
  - Source of truth for all messages
  - `create()`, `get()`, `addMessage()`, `getHistory()`, `list()`, `search()`, `delete()`

### User & Coordination

- **[User Operations](/api-reference/user-operations)** - User profiles + GDPR
  - Shared user data across all memory spaces
  - GDPR cascade deletion by userId (SDK + Cloud Mode)
  - Version history and time-travel queries
  - `get()`, `update()`, `delete()`, `search()`, `list()`, `export()`
- **[Sessions Operations](/api-reference/sessions-operations)** - Session lifecycle management
  - Multi-session support (web, mobile, API)
  - Activity tracking and idle detection
  - Configurable timeouts via Governance API
  - `create()`, `get()`, `getOrCreate()`, `touch()`, `end()`, `getActive()`, `expireIdle()`
- **[Auth Integration](/integrations/auth-providers)** - Authentication context
  - Framework-agnostic auth integration
  - Multi-tenancy support (tenantId auto-injection)
  - Works with Auth0, Clerk, NextAuth, Firebase, custom JWT
- **[Agent Management](/api-reference/agent-management)** - Agent registry (superseded by Memory Spaces)
  - Optional metadata registration for discovery/analytics
  - Cascade deletion by participantId across all spaces
  - Use `cortex.memorySpaces.*` for production isolation
- **[Context Operations](/api-reference/context-operations)** - Workflow coordination
  - Hierarchical task tracking (parent/child chains)
  - Multi-agent collaboration
  - Cross-memorySpace delegation
  - `create()`, `get()`, `update()`, `delete()`, `getChain()`, `getChildren()`
- **[A2A Communication](/api-reference/a2a-communication)** - Inter-agent messaging
  - Helper API built on memory system (`source.type='a2a'`)
  - Bidirectional storage (sender + receiver)
  - `send()`, `request()` (requires pub/sub), `broadcast()`, `getConversation()`

### Advanced Storage

- **[Immutable Store](/api-reference/immutable-store-api)** - Layer 1b
  - TRULY shared (no memorySpace scoping), versioned, immutable data
  - KB articles, policies, audit logs
  - `store()`, `get()`, `getVersion()`, `getHistory()`, `purge()`
- **[Mutable Store](/api-reference/mutable-store-api)** - Layer 1c
  - TRULY shared (no memorySpace scoping), mutable, current-value data
  - ACID transactions, atomic operations
  - `set()`, `get()`, `update()`, `increment()`, `transaction()`, `delete()`
- **[Facts Operations](/api-reference/facts-operations)** - Layer 3 Facts Store
  - Structured knowledge with versioning and confidence
  - Belief Revision System (v0.24.0+): `revise()`, `checkConflicts()`, `supersede()`
  - Enriched extraction (v0.15.0+): `searchAliases`, `semanticContext`, `entities`, `relations`
  - `store()`, `get()`, `update()`, `delete()`, `search()`, `queryBySubject()`, `history()`

### Platform & Governance

- **[Governance Policies](/api-reference/governance-policies-api)** - Retention rules & compliance
  - Per-layer, per-type, importance-based retention rules
  - Compliance templates: GDPR, HIPAA, SOC2, FINRA
  - Session lifecycle policies
  - `setPolicy()`, `getPolicy()`, `enforce()`, `simulate()`
- **[Graph Operations](/api-reference/graph-operations)** - Graph database integration (v0.7.0+)
  - Optional integration with Neo4j, Memgraph
  - Real-time sync via GraphSyncWorker
  - Multi-hop traversal and orphan cleanup
  - `syncToGraph` option across all APIs

### Reference

- **[Types & Interfaces](/reference/types-interfaces)** - TypeScript definitions
- **[Error Handling](/reference/error-handling)** - Error codes and debugging

---

## Quick Start

### 5-Minute Example

```typescript
import { Cortex } from "@cortexmemory/sdk";

// 1. Initialize Cortex with optional LLM for auto fact extraction
const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL,
  // Optional: Enable auto fact extraction
  llm: {
    provider: "openai",
    apiKey: process.env.OPENAI_API_KEY,
  },
});

// 2. Store user-agent exchange - Full orchestration in ONE call!
// remember() now auto-registers: memory space, user profile, conversation
const result = await cortex.memory.remember({
  memorySpaceId: "support-bot-space", // Auto-registered if not exists
  conversationId: "conv-001", // Auto-created if not exists
  userMessage: "My password is Blue123",
  agentResponse: "I'll remember that securely!",
  userId: "user-123", // Auto-creates user profile
  userName: "Alex Johnson", // Required with userId
  importance: 100,
  tags: ["password", "security"],
});

// 3. Search memories (semantic)
const memories = await cortex.memory.search(
  "support-bot-space",
  "user password",
  {
    embedding: await embed("user password"),
    userId: "user-123",
    minImportance: 70,
  },
);

console.log("Found:", memories[0].content); // "My password is Blue123"

// 4. User profile (shared across all memory spaces)
await cortex.users.update("user-123", {
  data: {
    displayName: "Alex Johnson",
    preferences: { theme: "dark" },
  },
});

// That's it! Your agent has persistent memory.
```

---

## Key Concepts

### The Four-Layer Architecture

<FlowDiagram 
  title="Four-Layer Architecture" 
  caption="Each layer serves a specific purpose"
>
  <FlowNode
    title="Layer 1: ACID Stores"
    icon="database"
    variant="primary"
  >
    1a: Conversations � 1b: Immutable (KB) � 1c: Mutable (config)
  </FlowNode>
  <FlowNode
    title="Layer 2: Vector Index"
    icon="search"
    variant="warning"
  >
    Semantic search � References Layer 1 via conversationRef
  </FlowNode>
  <FlowNode
    title="Layer 3: Facts Store"
    icon="brain"
    variant="success"
  >
    LLM-extracted facts � Belief Revision � 60-90% token savings
  </FlowNode>
  <FlowNode
    title="Layer 4: Convenience API"
    icon="layers"
    variant="default"
  >
    cortex.memory.* � Primary developer interface
  </FlowNode>
</FlowDiagram>

<Callout type="tip">
**Most developers use Layer 4** (`cortex.memory.*`) - it handles Layers 1, 2, and 3 automatically.
</Callout>

### Universal Filters

**Key Design Principle:** The same filters work across ALL operations.

```typescript
// Define filters once
const filters = {
  userId: "user-123",
  tags: ["preferences"],
  minImportance: 50,
  createdAfter: new Date("2025-10-01"),
};

// Use everywhere
await cortex.memory.search(memorySpaceId, query, filters);
await cortex.memory.count(memorySpaceId, filters);
await cortex.memory.list(memorySpaceId, filters);
await cortex.memory.updateMany(memorySpaceId, filters, updates);
await cortex.memory.deleteMany(memorySpaceId, filters);
await cortex.memory.export(memorySpaceId, filters);
```

**Supported Filters:**

- `userId`, `tags`, `importance`, `createdBefore/After`
- `accessCount`, `version`, `source.type`
- Any `metadata.*` field

### Automatic Versioning

Updates don't overwrite - they create new versions:

```typescript
// v1
await cortex.memory.store('user-123-personal', {
  content: 'Password is Blue',
  ...
});

// v2 (v1 preserved in history)
await cortex.memory.update('user-123-personal', memoryId, {
  content: 'Password is Red',
});

// Access history
const memory = await cortex.memory.get('user-123-personal', memoryId);
console.log(memory.version); // 2
console.log(memory.previousVersions[0].content); // "Password is Blue"
```

**Retention:** Default 10 versions (configurable per agent)

### GDPR Cascade Deletion

<Callout type="info">
**Cloud Mode Only**: Automatic cascade requires Cortex Cloud
</Callout>

One call deletes from ALL stores with `userId`:

```typescript
// Cloud Mode: One-click GDPR compliance
await cortex.users.delete("user-123", { cascade: true });

// Automatically deletes from:
// ? Conversations (Layer 1a) across ALL memory spaces
// ? Immutable records (Layer 1b)
// ? Mutable keys (Layer 1c)
// ? Vector memories (Layer 2) across ALL memory spaces
// ? Facts (Layer 3) across ALL memory spaces
```

**Direct Mode:** Manual deletion from each store (see User Operations API).

### Belief Revision System (v0.24.0+)

<Callout type="tip">
**New in v0.24.0**: Intelligent fact management that prevents duplicates and maintains knowledge consistency.
</Callout>

When facts are extracted from conversations, the Belief Revision System automatically:

1. **Detects conflicts** using slot matching (fast) and semantic matching (accurate)
2. **Resolves conflicts** using LLM-based decision making
3. **Takes appropriate action**: CREATE, UPDATE, SUPERSEDE, or skip
4. **Logs all changes** for audit trails

<FlowDiagram 
  title="Belief Revision Flow" 
  caption="How conflicts are detected and resolved"
>
  <FlowNode
    title="New Fact"
    icon="file"
    variant="primary"
  >
    Incoming fact to process
  </FlowNode>
  <FlowNode
    title="Slot Match?"
    icon="search"
    variant="warning"
  >
    Fast matching by subject/predicate
  </FlowNode>
  <FlowNode
    title="Semantic Match?"
    icon="brain"
    variant="warning"
  >
    Accurate matching by meaning
  </FlowNode>
  <FlowNode
    title="LLM Decision"
    icon="bot"
    variant="success"
  >
    UPDATE � SUPERSEDE � NONE
  </FlowNode>
</FlowDiagram>

**Example:**

```typescript
// Day 1: "User likes blue"
// Day 2: "User prefers purple"
// ? Automatically supersedes the old fact, maintains history

// Check conflicts before storing
const conflicts = await cortex.facts.checkConflicts({
  memorySpaceId: "user-123-space",
  fact: {
    fact: "User prefers purple",
    subject: "user-123",
    predicate: "favorite color",
    object: "purple",
    confidence: 90,
  },
});

if (conflicts.hasConflicts) {
  console.log(`Recommended: ${conflicts.recommendedAction}`);
  // SUPERSEDE - Color preference has changed
}

// Get history for any fact
const history = await cortex.facts.history("fact-123");
// Shows CREATE ? UPDATE ? SUPERSEDE chain
```

**See**: [Facts Operations API - Belief Revision](/api-reference/facts-operations#belief-revision-system-v0240)

---

## Common Patterns

### Pattern 1: Simple Chatbot (Hive Mode)

```typescript
// User sends message - use shared memory space
const memorySpaceId = `user-${req.user.id}-personal`; // Hive space

const conversation = await cortex.conversations.getOrCreate({
  type: "user-agent",
  memorySpaceId,
  participants: { userId: req.user.id, participantId: "chatbot" },
});

// Store exchange
await cortex.memory.remember({
  memorySpaceId,
  participantId: "chatbot", // Track who stored it
  conversationId: conversation.conversationId,
  userMessage: req.body.message,
  agentResponse: response,
  userId: req.user.id,
  userName: req.user.name,
});

// Search for context (infinite context pattern)
const context = await cortex.memory.search(memorySpaceId, req.body.message, {
  embedding: await embed(req.body.message),
  userId: req.user.id,
  limit: 10, // Top 10 most relevant from ALL history
});
```

### Pattern 2: Multi-Agent Workflow (Collaboration Mode)

```typescript
// Supervisor agent creates context in its own space
const context = await cortex.contexts.create({
  purpose: "Process refund request",
  memorySpaceId: "supervisor-agent-space", // Separate space
  userId: "user-123",
});

// Delegate via A2A (dual-write to both spaces)
await cortex.a2a.send({
  from: "supervisor-agent",
  to: "finance-agent",
  message: "Approve $500 refund",
  userId: "user-123",
  contextId: context.id,
  importance: 85,
});
// Stored in BOTH supervisor-agent-space AND finance-agent-space

// Finance agent accesses context (cross-space via context chain)
const ctx = await cortex.contexts.get(context.id, {
  requestingSpace: "finance-agent-space", // Cross-space access
});
```

### Pattern 3: Knowledge Base

```typescript
// Store KB article (shared, versioned)
await cortex.immutable.store({
  type: "kb-article",
  id: "refund-policy",
  data: {
    title: "Refund Policy",
    content: "Refunds available within 30 days...",
  },
  metadata: {
    importance: 90,
    tags: ["policy", "refunds"],
  },
});

// Index for search (optional) - in a memory space
await cortex.vector.store("support-bot-space", {
  content: "Refund Policy: Refunds available within 30 days...",
  immutableRef: {
    type: "kb-article",
    id: "refund-policy",
  },
  metadata: { importance: 90, tags: ["policy"] },
});

// Search within memory space
const results = await cortex.memory.search(
  "support-bot-space",
  "refund policy",
);
```

### Pattern 4: Live Inventory

```typescript
// Set inventory (mutable, no versioning)
await cortex.mutable.set("inventory", "widget-qty", 100);

// Customer orders (atomic decrement)
await cortex.mutable.update("inventory", "widget-qty", (qty) => {
  if (qty < 10) throw new Error("Out of stock");
  return qty - 10;
});

// Check availability
const qty = await cortex.mutable.get("inventory", "widget-qty");
console.log(`${qty} available`);
```

### Pattern 5: Fact-Based Knowledge (Infinite Context)

```typescript
// Extract and store facts (60-90% token savings for infinite context)
await cortex.memory.remember({
  memorySpaceId: "user-123-personal",
  participantId: "personal-assistant",
  conversationId: "conv-123",
  userMessage: "I work at Acme Corp in San Francisco as a senior engineer",
  agentResponse: "Thanks for sharing!",
  userId: "user-123",
  userName: "Alice",
  extractFacts: true, // Extract facts (Layer 3)
  storeRaw: true, // Also keep raw (Layer 1a, hybrid approach)
});

// Facts extracted and stored in Layer 3:
// 1. "User works at Acme Corp"
// 2. "User located in San Francisco"
// 3. "User's role: Senior Engineer"

// Search facts (fast, precise, unlimited history)
const facts = await cortex.memory.search(
  "user-123-personal",
  "user employment",
  {
    userId: "user-123",
    contentType: "fact", // Only facts from Layer 3
    limit: 5,
  },
);
// Retrieves from ALL past conversations (infinite context!)
```

### Pattern 6: Cross-Application Memory (MCP)

```typescript
// Run MCP server
// $ cortex-mcp-server --convex-url=$CONVEX_URL

// Now Cursor, Claude Desktop, etc. all share memory

// In Cursor: "I prefer TypeScript"
// ? Stored via MCP

// In Claude: "What language does user prefer?"
// ? Claude queries MCP
// ? Retrieves "User prefers TypeScript"
// ? Personalizes response ?

// Your memory follows you across all AI tools!
```

### Pattern 7: Graph Traversal (Advanced)

```typescript
// Graph-Lite (built-in): Context hierarchy
const chain = await cortex.contexts.get(contextId, {
  includeChain: true, // Multi-hop graph walk
});

console.log("Ancestors:", chain.ancestors.length); // Walk up
console.log("Descendants:", chain.descendants.length); // Walk down

// Native Graph DB (if integrated): Complex queries
const related = await cortex.graph.traverse({
  start: { type: "user", id: "user-123" },
  relationships: ["CREATED", "TRIGGERED", "HANDLED_BY"],
  maxDepth: 10,
});

console.log("All entities user touched:", related);
```

---

## API Conventions

### Naming Patterns

- **Operations**: Verb-based (`create`, `get`, `update`, `delete`, `search`)
- **Namespaces**: Plural (`conversations`, `users`, `contexts`, `agents`)
- **Options**: `*Options` suffix (`SearchOptions`, `DeleteOptions`)
- **Results**: `*Result` suffix (`RememberResult`, `DeleteResult`)
- **Filters**: `*Filters` suffix (`UniversalFilters`, `UserFilters`)

### Return Values

- **Single item**: `Entity | null`
- **Multiple items**: `Entity[]`
- **With pagination**: `{ items: Entity[], total: number, hasMore: boolean }`
- **Operations**: `*Result` interface with details

### Async/Await

All Cortex operations are async:

```typescript
// ? Always use await
const memory = await cortex.memory.get("agent-1", memoryId);

// ? Don't forget await
const memory = cortex.memory.get("agent-1", memoryId); // Returns Promise!
```

### Error Handling

All errors are catchable with type information:

```typescript
try {
  await cortex.memory.store("agent-1", data);
} catch (error) {
  if (error instanceof CortexError) {
    console.log(`Error: ${error.code}`);
    // Type-safe error handling
  }
}
```

---

## Direct Mode vs Cloud Mode

### Direct Mode (Free, Open Source)

**What you get:**

<FeatureGrid>
  <FeatureCard
    icon="database"
    title="Full Storage APIs"
    description="All layers available"
    size="medium"
  />
  <FeatureCard
    icon="brain"
    title="All Memory Operations"
    description="Complete memory management"
    size="medium"
  />
  <FeatureCard
    icon="search"
    title="Universal Filters"
    description="Same filters work everywhere"
    size="medium"
  />
</FeatureGrid>

<FeatureGrid>
  <FeatureCard
    icon="history"
    title="Automatic Versioning"
    description="Track all changes"
    size="large"
  />
  <FeatureCard
    icon="settings"
    title="Complete Flexibility"
    description="Full control over your setup"
    size="large"
  />
</FeatureGrid>

**What you provide:**

- Your Convex instance
- Your embeddings (OpenAI, Cohere, local)
- Agent execution infrastructure
- Pub/sub for A2A (optional)

**Example:**

```typescript
const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL,

  // Optional: LLM config for auto fact extraction
  llm: {
    provider: "openai",
    apiKey: process.env.OPENAI_API_KEY,
    model: "gpt-4o-mini",
  },

  // Optional: Graph database integration
  graph: {
    adapter: graphAdapter,
    autoSync: true,
  },
});

// Full orchestration with remember() - auto-registers entities
await cortex.memory.remember({
  memorySpaceId: "user-123-space", // Auto-registered if not exists
  userId: "user-123", // Auto-creates user profile
  userName: "Alex",
  conversationId: "conv-456",
  userMessage: "User prefers dark mode",
  agentResponse: "I'll remember that preference!",
  // ? Facts auto-extracted if LLM configured
  // ? Graph synced if adapter configured
});
```

### Cloud Mode (Managed, Premium)

**Additional features:**

<FeatureGrid>
  <FeatureCard
    icon="lock"
    title="GDPR Cascade"
    description="One-click deletion across all stores"
  />
  <FeatureCard
    icon="brain"
    title="Auto-Embeddings"
    description="No API keys needed"
  />
  <FeatureCard
    icon="message"
    title="Managed Pub/Sub"
    description="Real-time A2A without infrastructure"
  />
  <FeatureCard
    icon="bot"
    title="Smart Store AI"
    description="Automatic update detection"
  />
  <FeatureCard
    icon="graph"
    title="Analytics Dashboard"
    description="Usage insights"
  />
  <FeatureCard
    icon="policy"
    title="Governance Policies"
    description="Automatic retention rules"
  />
</FeatureGrid>

**Example:**

```typescript
const cortex = new Cortex({
  mode: 'cloud',
  apiKey: process.env.CORTEX_CLOUD_KEY,
});

// Auto-embeddings (Cloud handles it)
await cortex.memory.store('agent-1', {
  content: 'User prefers dark mode',
  autoEmbed: true,  // ? Cloud Mode generates embedding
  ...
});

// GDPR cascade (Cloud only)
await cortex.users.delete('user-123', { cascade: true });
// Deletes from ALL stores automatically ?
```

---

## Navigation Guide

### By Use Case

**I want to...**

**Store conversation messages:**
? [Memory Operations](/api-reference/memory-operations#remember) - `cortex.memory.remember()`

**Search agent memories:**
? [Memory Operations](/api-reference/memory-operations#search) - `cortex.memory.search()`

**Manage user profiles:**
? [User Operations](/api-reference/user-operations) - `cortex.users.*`

**Delete user data (GDPR):**
? [User Operations](/api-reference/user-operations#delete) - `cortex.users.delete({ cascade: true })`

**Track multi-agent workflows:**
? [Context Operations](/api-reference/context-operations) - `cortex.contexts.*`

**Send agent-to-agent messages:**
? [A2A Communication](/api-reference/a2a-communication) - `cortex.a2a.send()`

**Store shared knowledge:**
? [Immutable Store](/api-reference/immutable-store-api) - `cortex.immutable.store()`

**Store live data (inventory, config):**
? [Mutable Store](/api-reference/mutable-store-api) - `cortex.mutable.set()`

**Set retention policies:**
? [Governance Policies](/api-reference/governance-policies-api) - `cortex.governance.*`

**Manage user sessions:**
? [Sessions Operations](/api-reference/sessions-operations) - `cortex.sessions.*`

**Store and query facts:**
? [Facts Operations](/api-reference/facts-operations) - `cortex.facts.*`

**Integrate graph database:**
? [Graph Operations](/api-reference/graph-operations) - GraphAdapter and GraphSyncWorker

**See all TypeScript types:**
? [Types & Interfaces](/reference/types-interfaces)

**Debug an error:**
? [Error Handling](/reference/error-handling)

### By Layer

**Layer 1a (ACID Conversations):**
? [Conversation Operations](/api-reference/conversation-operations)

**Layer 1b (Immutable Store):**
? [Immutable Store](/api-reference/immutable-store-api)

**Layer 1c (Mutable Store):**
? [Mutable Store](/api-reference/mutable-store-api)

**Layer 2 (Vector Index):**
? [Memory Operations](/api-reference/memory-operations) - `cortex.vector.*`

**Layer 3 (Facts Store):**
? [Facts Operations](/api-reference/facts-operations) - `cortex.facts.*`

**Layer 4 (Convenience API):**
? [Memory Operations](/api-reference/memory-operations) - `cortex.memory.*`

**Sessions:**
? [Sessions Operations](/api-reference/sessions-operations) - `cortex.sessions.*`

---

## Core Principles

### 1. Layered Architecture

Cortex separates **storage** (immutable source) from **search** (optimized index):

- **Layer 1**: ACID stores (conversations, immutable, mutable) - Never lose data
- **Layer 2**: Vector index - Fast searchable, versioned, retention rules
- **Layer 3**: Facts store - Structured knowledge with versioning and belief revision
- **Layer 4**: Memory API - Convenience wrapper over Layers 1-3

**Benefits:**

- Retention on Vector doesn't lose ACID source
- Facts provide 60-90% token savings for infinite context
- Can always retrieve full context
- Fast search + complete audit trail

### 2. References Over Duplication

Data is linked, not duplicated:

```typescript
// Vector memory references ACID conversation
{
  id: 'mem-123',
  content: 'User password is Blue',
  conversationRef: {
    conversationId: 'conv-456',
    messageIds: ['msg-001'],  // ? Link to source
  }
}

// Can always get full context
const conversation = await cortex.conversations.get('conv-456');
const originalMessage = conversation.messages.find(m => m.id === 'msg-001');
```

### 3. Importance Scale (0-100)

Granular importance for filtering and retention:

- **90-100**: Critical (passwords, security)
- **70-89**: High (user preferences, decisions)
- **40-69**: Medium (conversation context) - default: 50
- **10-39**: Low (casual observations)
- **0-9**: Trivial (debug logs)

```typescript
await cortex.memory.store("agent-1", {
  content: "System password is XYZ",
  metadata: { importance: 100 }, // Critical
});

// Search only important
const important = await cortex.memory.search("agent-1", query, {
  minImportance: 70,
});
```

### 4. Optional userId for GDPR

All stores support optional `userId` field:

```typescript
// With userId (GDPR-enabled)
await cortex.conversations.addMessage('conv-123', {
  userId: 'user-123',  // ? Links to user
  ...
});

await cortex.immutable.store({
  type: 'feedback',
  userId: 'user-123',  // ? GDPR cascade target
  ...
});

// GDPR cascade finds and deletes all
await cortex.users.delete('user-123', { cascade: true });
```

### 5. Automatic Versioning

Updates create new versions, not overwrites:

```typescript
// Every update preserves history
await cortex.memory.update("agent-1", memoryId, { content: "New value" });

// Previous version still accessible
const history = await cortex.memory.getHistory("agent-1", memoryId);
```

---

## Common Operations Cheat Sheet

### Memory Operations

```typescript
// Store conversation (ACID + Vector)
await cortex.memory.remember({
  memorySpaceId,
  participantId, // Optional: Hive Mode tracking
  conversationId,
  userMessage,
  agentResponse,
  userId,
  userName,
});

// Store system memory (Vector only)
await cortex.vector.store(memorySpaceId, {
  content,
  source: { type: "system" },
  metadata,
});

// Search
await cortex.memory.search(memorySpaceId, query, {
  embedding,
  userId,
  minImportance,
  limit,
  participantId, // Optional: Filter by participant
});

// Get
await cortex.memory.get(memorySpaceId, memoryId, { includeConversation: true });

// Update
await cortex.memory.update(memorySpaceId, memoryId, { content, metadata });

// Delete (preserves ACID)
await cortex.memory.delete(memorySpaceId, memoryId);

// Count
await cortex.memory.count(memorySpaceId, filters);

// List
await cortex.memory.list(memorySpaceId, { limit, offset, sortBy });

// Export
await cortex.memory.export(memorySpaceId, { userId, format: "json" });
```

### User Operations

```typescript
// Create/update
await cortex.users.update(userId, {
  data: { displayName, email, preferences },
});

// Get
await cortex.users.get(userId);

// Delete (Cloud Mode - cascade across all stores)
await cortex.users.delete(userId, { cascade: true });

// Search
await cortex.users.search({ data: { tier: "pro" } });

// Count
await cortex.users.count({ createdAfter: new Date("2025-01-01") });
```

### Context Operations

```typescript
// Create workflow
const ctx = await cortex.contexts.create({
  purpose,
  memorySpaceId, // Which memory space
  userId,
  parentId, // Cross-space parent allowed
  data,
});

// Get with chain (supports cross-space traversal)
await cortex.contexts.get(contextId, {
  includeChain: true,
  requestingSpace: memorySpaceId, // For cross-space access
});

// Update status
await cortex.contexts.update(contextId, { status: "completed", data });

// Delete with children
await cortex.contexts.delete(contextId, { cascadeChildren: true });

// Search
await cortex.contexts.search({
  memorySpaceId,
  status: "active",
  data: { importance: { $gte: 80 } },
});
```

### A2A Communication

```typescript
// Send message
await cortex.a2a.send({ from, to, message, importance, userId, contextId });

// Request-response (requires pub/sub)
const response = await cortex.a2a.request({ from, to, message, timeout });

// Broadcast
await cortex.a2a.broadcast({ from, to: [agent1, agent2, agent3], message });

// Get conversation
await cortex.a2a.getConversation(agent1, agent2, {
  since,
  minImportance,
  tags,
});
```

### Immutable Store

```typescript
// Store versioned data
await cortex.immutable.store({ type, id, data, userId, metadata });

// Get current version
await cortex.immutable.get(type, id);

// Get specific version
await cortex.immutable.getVersion(type, id, version);

// Get history
await cortex.immutable.getHistory(type, id);

// Purge
await cortex.immutable.purge(type, id);
```

### Mutable Store

```typescript
// Set value
await cortex.mutable.set(namespace, key, value, userId);

// Get value
await cortex.mutable.get(namespace, key);

// Atomic update
await cortex.mutable.update(namespace, key, (current) => current + 1);

// Transaction
await cortex.mutable.transaction(async (tx) => {
  tx.update("inventory", "product-a", (qty) => qty - 1);
  tx.update("counters", "sales", (n) => n + 1);
});

// Delete
await cortex.mutable.delete(namespace, key);
```

---

## Best Practices

### 1. Start with Layer 4

Use `cortex.memory.*` for most operations:

```typescript
// ? Recommended: Layer 4 (handles L1a + L2 + L3)
await cortex.memory.remember({ ... });

// ?? Advanced: Manual Layer 1 + Layer 2 + Layer 3
const msg = await cortex.conversations.addMessage(...);
await cortex.vector.store(...);
await cortex.facts.store(...);
```

### 2. Always Link to ACID

Link Vector memories to their source:

```typescript
// ? Good: With conversationRef
await cortex.vector.store('user-123-personal', {
  content: 'User prefers dark mode',
  conversationRef: {
    conversationId: 'conv-123',
    messageIds: ['msg-456'],
  },
  ...
});

// ?? Only omit for non-conversation sources
```

### 3. Use Universal Filters

Define filters once, reuse everywhere:

```typescript
const oldDebugLogs = {
  tags: ["debug"],
  importance: { $lte: 10 },
  createdBefore: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
};

// Preview
const count = await cortex.memory.count("user-123-personal", oldDebugLogs);

// Export
await cortex.memory.export("user-123-personal", {
  ...oldDebugLogs,
  format: "json",
});

// Delete
await cortex.memory.deleteMany("user-123-personal", oldDebugLogs);
```

### 4. Handle Errors

Always catch and handle errors:

```typescript
try {
  await cortex.memory.store("user-123-personal", data);
} catch (error) {
  if (error instanceof CortexError) {
    console.error(`Cortex error: ${error.code}`);
    // Handle specific error codes
  }
}
```

### 5. Set userId for GDPR

Link user-related data for compliance:

```typescript
// ? With userId (GDPR-enabled)
await cortex.memory.store('user-123-personal', {
  userId: 'user-123',  // ? Critical for GDPR
  ...
});

await cortex.immutable.store({
  type: 'feedback',
  userId: 'user-123',  // ? Enables cascade deletion
  ...
});
```

---

## Quick Reference

### Import

```typescript
import { Cortex } from "@cortexmemory/sdk";
import type { MemoryEntry, UserProfile, Context } from "@cortexmemory/sdk";
```

### Initialize

```typescript
// Direct Mode
const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL,
});

// Cloud Mode
const cortex = new Cortex({
  mode: "cloud",
  apiKey: process.env.CORTEX_CLOUD_KEY,
});
```

### Core Namespaces

```typescript
cortex.memory.*          // Layer 4: Memory convenience API (primary interface)
cortex.memorySpaces.*    // Memory space management (Hive/Collaboration)
cortex.conversations.*   // Layer 1a: ACID conversations (memorySpace-scoped)
cortex.immutable.*       // Layer 1b: Shared versioned data (NO memorySpace)
cortex.mutable.*         // Layer 1c: Shared live data (NO memorySpace)
cortex.vector.*          // Layer 2: Vector index (memorySpace-scoped)
cortex.facts.*           // Layer 3: Facts store (memorySpace-scoped, LLM extraction)
cortex.users.*           // User profiles + GDPR (shared across all spaces)
cortex.contexts.*        // Workflow coordination (cross-space support)
cortex.a2a.*             // Inter-agent messaging
cortex.governance.*      // Retention policies & compliance
cortex.sessions.*        // Session lifecycle management
cortex.agents.*          // Agent registry (optional, superseded by memorySpaces)

// External imports (not on cortex object)
import { CypherGraphAdapter, GraphSyncWorker } from "@cortexmemory/sdk";
// Graph adapter configured via Cortex constructor: graph: { adapter: ... }
```

### Most Used Operations

```typescript
// 1. Remember conversation
await cortex.memory.remember({
  memorySpaceId,
  participantId, // Optional: Hive Mode tracking
  conversationId,
  userMessage,
  agentResponse,
  userId,
  userName,
});

// 2. Search memories (infinite context pattern)
await cortex.memory.search(memorySpaceId, query, { embedding, filters });

// 3. Update user profile
await cortex.users.update(userId, { data });

// 4. Send inter-space message (Collaboration Mode)
await cortex.a2a.send({ from, to, message });

// 5. Create context
await cortex.contexts.create({ purpose, memorySpaceId, userId });
```

---

## Getting Help

### Documentation

- **[Memory Operations](/api-reference/memory-operations)** - Most comprehensive guide
- **[Facts Operations](/api-reference/facts-operations)** - Structured knowledge and Belief Revision
- **[Sessions Operations](/api-reference/sessions-operations)** - Session lifecycle management
- **[Types & Interfaces](/reference/types-interfaces)** - TypeScript reference
- **[Error Handling](/reference/error-handling)** - Debugging guide

### Community

- **GitHub Discussions** - Ask questions, share patterns

### Found a Bug?

1. Check [Error Handling](/reference/error-handling) for known issues
2. Search GitHub Issues for existing reports
3. Open new issue with minimal reproduction

---

## Next Steps

**New to Cortex?**
? Start with [Memory Operations](/api-reference/memory-operations) - the main API

**Building multi-agent systems?**
? Read [Context Operations](/api-reference/context-operations) and [A2A Communication](/api-reference/a2a-communication)

**Need GDPR compliance?**
? Check [User Operations](/api-reference/user-operations#delete) for cascade deletion

**Working with facts and knowledge?**
? Explore [Facts Operations](/api-reference/facts-operations) and the Belief Revision System

**Managing user sessions?**
? Check [Sessions Operations](/api-reference/sessions-operations) for activity tracking

**Working with shared data?**
? Explore [Immutable Store](/api-reference/immutable-store-api) and [Mutable Store](/api-reference/mutable-store-api)

**Integrating graph databases?**
? Review [Graph Operations](/api-reference/graph-operations) for Neo4j/Memgraph integration

**TypeScript user?**
? Review [Types & Interfaces](/reference/types-interfaces) for complete definitions

---

<QuickNav>
  <QuickNavItem
    title="Memory Operations"
    description="Primary API for storing and searching memories"
    href="/api-reference/memory-operations"
  />
  <QuickNavItem
    title="Memory Spaces"
    description="Isolation boundaries and Hive Mode"
    href="/api-reference/memory-space-operations"
  />
  <QuickNavItem
    title="Conversations"
    description="ACID conversation storage"
    href="/api-reference/conversation-operations"
  />
  <QuickNavItem
    title="Facts"
    description="Structured knowledge with Belief Revision"
    href="/api-reference/facts-operations"
  />
</QuickNav>

---

**Questions?** Ask in [GitHub Discussions](https://github.com/SaintNick1214/cortex/discussions).
