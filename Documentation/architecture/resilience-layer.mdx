---
id: resilience-layer
title: Resilience Layer
sidebar_position: 14
description: Automatic retries, circuit breaking, and fault tolerance
---

# Resilience Layer

<Callout type="info"> **Last Updated**: 2026-01-08 </Callout>

<Callout type="info" title="Built-in Resilience">
  All Cortex operations include automatic:
  - **Rate limiting** - Smooths traffic bursts
  - **Concurrency control** - Respects Convex limits (16 concurrent on free plan)
  - **Circuit breaking** - Fast-fails when backend is unhealthy
  - **Priority queuing** - Critical operations execute first
</Callout>

---

## Why It Matters

Without protection, traffic spikes overwhelm your database:

<Tabs>
  <TabItem value="without" label="Without Resilience">

<FlowDiagram title="System Failure" direction="horizontal">
  <FlowNode title="100 Agents Burst" icon="users" variant="primary">Simultaneous requests</FlowNode>
  <FlowNode title="100 Concurrent Queries" icon="database" variant="warning">All hit database</FlowNode>
  <FlowNode title="System Fails" icon="shield" variant="danger">Convex rejects (limit: 16) • Errors cascade</FlowNode>
</FlowDiagram>

  </TabItem>
  <TabItem value="with" label="With Resilience">

<FlowDiagram title="Graceful Handling" direction="horizontal">
  <FlowNode title="100 Agents Burst" icon="users" variant="primary">Simultaneous requests</FlowNode>
  <FlowNode title="Rate Limiter" icon="server" variant="secondary">Smooths traffic</FlowNode>
  <FlowNode title="All Succeed" icon="shield" variant="success">16 execute • 84 queue with priority</FlowNode>
</FlowDiagram>

  </TabItem>
</Tabs>

---

## Quick Start

### Zero Configuration

Resilience is enabled by default with safe settings for Convex Free plan:

```typescript
import { Cortex } from '@cortexmemory/sdk';

const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL!,
  // Resilience enabled automatically
});

// All operations automatically protected
await cortex.memory.remember({...});
```

### Environment Variable

Set `CONVEX_PLAN` to auto-configure for your subscription:

```bash
# .env
CONVEX_PLAN=free          # 16 concurrent (default)
CONVEX_PLAN=professional  # 256 concurrent
```

```typescript
import { getPresetForPlan } from '@cortexmemory/sdk';

const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL!,
  resilience: getPresetForPlan(),  // Reads CONVEX_PLAN
});
```

---

## Configuration Options

<APITable parameters={[
  { name: "enabled", type: "boolean", required: false, default: "true", description: "Enable/disable resilience layer" },
  { name: "rateLimiter.bucketSize", type: "number", required: false, default: "100", description: "Rate limiter burst capacity" },
  { name: "rateLimiter.refillRate", type: "number", required: false, default: "50", description: "Tokens per second (rate limit)" },
  { name: "concurrency.maxConcurrent", type: "number", required: false, default: "20", description: "Max simultaneous operations" },
  { name: "concurrency.queueSize", type: "number", required: false, default: "1000", description: "Max queued requests" },
  { name: "concurrency.timeout", type: "number", required: false, default: "30000", description: "Request timeout (ms)" },
  { name: "circuitBreaker.failureThreshold", type: "number", required: false, default: "5", description: "Failures before circuit opens" },
  { name: "circuitBreaker.successThreshold", type: "number", required: false, default: "2", description: "Successes in half-open to close circuit" },
  { name: "circuitBreaker.timeout", type: "number", required: false, default: "30000", description: "Time to wait in open state before half-open (ms)" },
  { name: "circuitBreaker.halfOpenMax", type: "number", required: false, default: "3", description: "Max test requests allowed in half-open state" },
  { name: "queue.maxSize", type: "object", required: false, default: "See defaults", description: "Max queue size per priority level (Partial<Record<Priority, number>>)" },
  { name: "retry.maxRetries", type: "number", required: false, default: "3", description: "Maximum number of retry attempts" },
  { name: "retry.baseDelayMs", type: "number", required: false, default: "500", description: "Base delay between retries (ms)" },
  { name: "retry.maxDelayMs", type: "number", required: false, default: "10000", description: "Maximum delay between retries (ms)" },
  { name: "retry.exponentialBase", type: "number", required: false, default: "2.0", description: "Exponential backoff base" },
  { name: "retry.jitter", type: "boolean", required: false, default: "true", description: "Add jitter to prevent thundering herd" },
]} />

### Custom Configuration

```typescript
const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL!,
  resilience: {
    enabled: true,
    
    rateLimiter: {
      bucketSize: 100,      // Max burst
      refillRate: 50,       // Per second
    },
    
    concurrency: {
      maxConcurrent: 16,    // Convex free limit
      queueSize: 1000,
      timeout: 30000,       // 30s
    },
    
    circuitBreaker: {
      failureThreshold: 5,  // Open after 5 failures
      successThreshold: 2,  // Close after 2 successes
      timeout: 30000,       // 30s recovery wait
      halfOpenMax: 3,       // Max test requests in half-open
    },
    
    queue: {
      maxSize: {            // Per-priority limits
        critical: 100,
        high: 500,
        normal: 1000,
        low: 2000,
        background: 5000,
      },
    },
    
    retry: {
      maxRetries: 3,        // Retry up to 3 times
      baseDelayMs: 500,     // Start with 0.5s delay
      maxDelayMs: 10000,    // Cap at 10s
      exponentialBase: 2.0, // Double delay each attempt
      jitter: true,         // Prevent thundering herd
    },
  },
});
```

---

## Presets

<Tabs>
  <TabItem value="default" label="default (Free Plan)">

Safe defaults for Convex Free/Starter (16 concurrent limit):

```typescript
import { ResiliencePresets } from '@cortexmemory/sdk';

const cortex = new Cortex({
  convexUrl: process.env.CONVEX_URL!,
  resilience: ResiliencePresets.default,
});
```

**Settings:** Max concurrent: 16, Bucket size: 100, Refill rate: 50/sec, Circuit threshold: 5 failures

  </TabItem>
  <TabItem value="realtime" label="realTimeAgent">

Low-latency settings for chat apps:

```typescript
resilience: ResiliencePresets.realTimeAgent
```

**Settings:** Max concurrent: 8 (conservative), Timeout: 5s (fail fast), Circuit threshold: 3 (trip quickly)

  </TabItem>
  <TabItem value="batch" label="batchProcessing">

High throughput for bulk operations (requires Professional plan):

```typescript
resilience: ResiliencePresets.batchProcessing
```

**Settings:** Max concurrent: 64, Queue size: 10,000, Timeout: 60s

  </TabItem>
  <TabItem value="hive" label="hiveMode">

Extreme concurrency for agent swarms (requires Professional plan):

```typescript
resilience: ResiliencePresets.hiveMode
```

**Settings:** Max concurrent: 128, Queue size: 50,000, Timeout: 120s

  </TabItem>
</Tabs>

<Callout type="warning" title="Professional Plan Required">
  `batchProcessing` and `hiveMode` presets require Convex Professional plan (256+ concurrent limit). Using with Free plan will cause queuing.
</Callout>

---

## Architecture

Four protection layers execute in sequence:

<FlowDiagram title="Resilience Layer Flow" caption="Request flows through four protection layers before reaching Convex">
  <FlowNode title="Request" icon="code" variant="default">Incoming request</FlowNode>
  <FlowNode title="Rate Limiter" icon="server" variant="primary">Smooth burst into tokens</FlowNode>
  <FlowNode title="Concurrency Limiter" icon="layers" variant="secondary">Queue excess requests</FlowNode>
  <FlowNode title="Circuit Breaker" icon="shield" variant="warning">Fast-fail if unhealthy</FlowNode>
  <FlowNode title="Convex" icon="database" variant="success">Backend database</FlowNode>
</FlowDiagram>

### Token Bucket Rate Limiter

Controls request **rate**. Bucket starts full, requests consume tokens, tokens refill over time.

<Callout type="tip" title="Exponential Backoff">
  When tokens depleted or retries occur, requests wait with exponential backoff:
  
  - Attempt 1: Immediate (0ms)
  - Attempt 2: ~500ms delay (baseDelayMs)
  - Attempt 3: ~1000ms delay (baseDelayMs × 2)
  - Attempt 4: ~2000ms delay (baseDelayMs × 4)
  
  Default `baseDelayMs: 500ms` with jitter (random factor 0.5-1.5x) to prevent thundering herd.
</Callout>

### Concurrency Limiter

Controls **how many** simultaneous requests. Max 16 concurrent on free plan. Excess requests queue by priority.

### Priority Queue

| Priority | Operations | Queue Size |
|----------|------------|------------|
| `critical` | Circuit breaker tests | 100 |
| `high` | User-facing reads | 500 |
| `normal` | Standard writes | 1,000 |
| `low` | Analytics | 2,000 |
| `background` | Cleanup | 5,000 |

### Circuit Breaker

Prevents cascading failures when backend is unhealthy:

<FlowDiagram title="Circuit Breaker State Transitions" caption="Circuit breaker transitions between CLOSED, OPEN, and HALF-OPEN states">
  <FlowNode title="CLOSED" icon="shield" variant="success">Normal operation - requests pass through</FlowNode>
  <FlowNode title="OPEN" icon="shield" variant="danger">5 failures detected - fast-fail mode</FlowNode>
  <FlowNode title="HALF-OPEN" icon="time" variant="warning">30s timeout - testing recovery</FlowNode>
</FlowDiagram>

**State Transitions:**
- CLOSED → OPEN: After 5 failures
- OPEN → HALF-OPEN: After 30s timeout
- HALF-OPEN → CLOSED: After 2 successes
- HALF-OPEN → OPEN: On any failure

---

## Monitoring

```typescript
const metrics = cortex.getResilienceMetrics();

console.log(metrics);
// {
//   rateLimiter: {
//     tokensAvailable: 87,
//     requestsThrottled: 15,
//     avgWaitTimeMs: 234
//   },
//   concurrency: {
//     active: 12,
//     waiting: 5,
//     maxReached: 16,
//     timeouts: 0
//   },
//   circuitBreaker: {
//     state: 'closed',
//     failures: 0,
//     lastStateChangeAt: 1234567890,
//     totalOpens: 0
//   },
//   queue: {
//     total: 5,
//     byPriority: {
//       critical: 0,
//       high: 2,
//       normal: 3,
//       low: 0,
//       background: 0
//     },
//     processed: 1234,
//     dropped: 5,
//     oldestRequestAgeMs: 1234
//   },
//   timestamp: 1234567890
// }

// Alert if circuit opens
if (metrics.circuitBreaker.state === 'open') {
  console.error('Backend unhealthy!');
}

// Alert if queue backing up
if (metrics.queue.total > 500) {
  console.warn(`Queue depth: ${metrics.queue.total}`);
}
```

---

## Error Handling

```typescript
import { CircuitOpenError, QueueFullError, AcquireTimeoutError } from '@cortexmemory/sdk';

try {
  await cortex.memory.remember({...});
} catch (error) {
  if (error instanceof CircuitOpenError) {
    // Backend unhealthy, circuit tripped
    console.error('Service unavailable, try later');
  } else if (error instanceof QueueFullError) {
    // System overloaded
    console.error('Too many requests, try later');
  } else if (error instanceof AcquireTimeoutError) {
    // Waited too long for permit
    console.error('Request timed out');
  }
}
```

---

## Best Practices

<Callout type="tip" title="Start with Defaults">

```typescript
// Good: Use defaults tuned for Convex Free plan
const cortex = new Cortex({ convexUrl: process.env.CONVEX_URL! });

// Avoid: Over-customizing without measurement
const cortex = new Cortex({
  resilience: { concurrency: { maxConcurrent: 100 } }  // Exceeds Convex limits!
});
```

</Callout>

<Callout type="tip" title="Match Preset to Plan">

```typescript
// Free/Starter: Use default or realTimeAgent
resilience: ResiliencePresets.default

// Professional: Can use batchProcessing or hiveMode
resilience: ResiliencePresets.batchProcessing
```

</Callout>

<Callout type="warning" title="Monitor Circuit State">

```typescript
const cortex = new Cortex({
  resilience: {
    onCircuitOpen: () => console.error('Circuit OPEN'),
    onCircuitClose: () => console.log('Circuit CLOSED'),
  },
});
```

</Callout>

---

## Graceful Shutdown

```typescript
// Wait for in-flight requests (with optional timeout)
await cortex.shutdown(30000); // Default: 30s timeout

// In server shutdown handler
process.on('SIGTERM', async () => {
  await cortex.shutdown();
  process.exit(0);
});
```

---

## Next Steps

<QuickNav>
  <QuickNavItem 
    title="Error Handling" 
    description="All error codes" 
    href="/reference/error-handling" 
  />
  <QuickNavItem 
    title="Performance" 
    description="Optimization guide" 
    href="/architecture/performance" 
  />
  <QuickNavItem 
    title="Hive Mode" 
    description="Multi-agent coordination" 
    href="/core-features/hive-mode" 
  />
</QuickNav>
